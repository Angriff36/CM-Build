{
  "master": {
    "tasks": [
      {
        "id": "11",
        "title": "Implement PrepChef single-tap primary action flow with WCAG-compliant touch targets",
        "description": "Redesign PrepChef mobile task interactions to use a single primary action per task, ensure all touch targets meet the 44px WCAG 2.1 AA minimum, and wire these actions to real backend APIs instead of simulated behavior.",
        "details": "Owner: @ui-ux (primary), @business-logic\nComplexity: 7/10\n\nScope & Files:\n- Target the PrepChef mobile app within the Turbo monorepo, e.g. `apps/prepchef-mobile/`.\n- Identify all main task interaction screens and components, e.g. `screens/TaskListScreen.tsx`, `screens/TaskDetailScreen.tsx`, `components/TaskCard.tsx`, `components/PrimaryActionButton.tsx`.\n\nFunctional Requirements:\n- Replace multiple competing action buttons on a task (e.g. Start, Pause, Done, More) with a single context-aware **primary action button** per task card and in the task detail view.\n- Ensure all interactive elements (buttons, list items, icons that trigger actions) have a minimum hit area of 44x44px while preserving existing layouts as much as possible.\n- All task state transitions must call the real Supabase-backed APIs, preserving existing API contracts; remove or gate any simulated behavior behind feature flags.\n- Maintain backward compatibility with existing data and workflows.\n- Latency requirement: touch interactions must render visual feedback (pressed state) within 100ms.\n\nImplementation Notes:\n- Use existing design system components from `@codemachine/ui` such as `Button`, `IconButton`, `Touchable`, updating sizing props to meet 44px targets.\n- Where icons are used as interactive controls, wrap them with a touchable container that enforces min width/height and increased padding.\n- Implement a state machine or simple mapping for the primary action per task status, for example:\n```ts\n// apps/prepchef-mobile/domain/taskActions.ts\nexport type TaskStatus = 'pending' | 'in_progress' | 'paused' | 'completed';\n\nexport type PrimaryAction = {\n  label: string;\n  icon: IconName;\n  nextStatus: TaskStatus;\n};\n\nexport const primaryActionForStatus: Record<TaskStatus, PrimaryAction> = {\n  pending:   { label: 'Start',  icon: 'play',  nextStatus: 'in_progress' },\n  in_progress: { label: 'Pause',  icon: 'pause', nextStatus: 'paused' },\n  paused:    { label: 'Resume', icon: 'play',  nextStatus: 'in_progress' },\n  completed: { label: 'Reopen', icon: 'undo',  nextStatus: 'in_progress' },\n};\n\nexport async function updateTaskStatus(taskId: string, nextStatus: TaskStatus) {\n  const { data, error } = await supabase\n    .from('tasks')\n    .update({ status: nextStatus })\n    .eq('id', taskId)\n    .select()\n    .single();\n  if (error) throw error;\n  return data;\n}\n```\n- Integrate the above helper in `TaskCard` and `TaskDetailScreen` primary button handlers.\n- Use the existing feature flag system (Flagsmith) to gate the new single-tap flow, e.g. `flags.prepchef_single_tap_flow`, to allow rollback.\n- Ensure all components remain server-side renderable (no client-only APIs during initial render; gate them behind `useEffect` or dynamic import with `ssr: false` if strictly necessary, keeping SSR for main screens).\n\nAccessibility & Performance:\n- Confirm minimum touch target by using design tokens for spacing/sizing that map to >=44px on target devices (tablet DPIs used in kitchens).\n- Avoid adding heavy libraries; keep any added computations O(1) per rendered task card to avoid jank.\n\nAcceptance Criteria:\n- 100% of interactive elements on main PrepChef task screens have hit areas >=44x44px (verified via design token mapping and manual inspection).\n- Each task shows exactly one clearly labeled primary action in list and detail views, with correct state transitions.\n- All primary actions call existing Supabase APIs with no simulated/no-op actions remaining on critical paths.\n- Interaction feedback appears within 100ms on representative kitchen tablets.\n- Feature can be toggled on/off via Flagsmith without breaking legacy flows.",
        "testStrategy": "Owner: @qa-automation\n\nAutomated Tests:\n- Add unit tests for `primaryActionForStatus` and `updateTaskStatus` in `apps/prepchef-mobile/domain/__tests__/taskActions.test.ts`.\n- Add integration tests with React Native Testing Library for `TaskCard` and `TaskDetailScreen` to verify that the correct primary action is rendered for each status and that pressing it calls the API with the expected payload.\n\nManual Tests:\n- On real kitchen tablets, navigate through the PrepChef main task lists and detail views and confirm that all touch targets can be reliably tapped with a thumb and visually meet or exceed 44px.\n- Use Chrome DevTools/React Native devtools with device emulation to verify clickable area bounding boxes.\n- Flip the `prepchef_single_tap_flow` feature flag on/off and verify that:\n  - With flag ON: single primary action flow is active and functional.\n  - With flag OFF: legacy multi-button flow functions as before.\n\nRegression & Performance:\n- Measure tap-to-visual-feedback latency with profiling tools; confirm <=100ms on test devices.\n- Run a smoke test of key PrepChef flows (view tasks, start, pause, complete) to ensure no API errors or data integrity issues.\n- Verify server-side rendering of screens still completes successfully in the monorepo build.",
        "priority": "high",
        "dependencies": [],
        "status": "deferred",
        "subtasks": [
          {
            "id": 1,
            "title": "Audit and update touch targets to 44px across TaskListScreen, TaskDetailScreen, TaskCard",
            "description": "Review all interactive elements in specified screens and components, update sizing, padding using design system tokens to ensure minimum 44x44px hit areas while preserving layouts.",
            "dependencies": [],
            "details": "Target files: screens/TaskListScreen.tsx, screens/TaskDetailScreen.tsx, components/TaskCard.tsx, components/PrimaryActionButton.tsx. Use @codemachine/ui Button, IconButton, Touchable with min width/height props and increased padding for icons. Verify on kitchen tablet DPIs.\n<info added on 2025-12-18T07:40:18.294Z>\nCompleted UI updates for Button component to support WCAG 44px touch targets.\n\nDetails:\n- File: libs/ui/src/components/Button.tsx\n- Changes: added size prop ('sm' | 'md' | 'lg' with lg = h-12 = 48px), fullWidth prop (responsive full-width on mobile), minTouch prop (enforces 44x44 min hit area), integrated design tokens (ink/graphite/paper), added story in Button.stories.tsx\n- Commit: 6807c78\n- Branch: realtime (pushed to origin/realtime)\n- Tests/Verification: updated Storybook entry for Button; manual inspection validated touch sizing.\n\nOwner: @ui-ux\nSubagent: ui-ux\n\nMarking this subtask as completed and setting status to 'done' per acceptance criteria.\n</info added on 2025-12-18T07:40:18.294Z>",
            "status": "done",
            "testStrategy": "Manual inspection with React Native Inspector hit area tool; design token mapping verification; screenshot comparisons pre/post update.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement primaryActionForStatus state machine and Supabase API integration",
            "description": "Create taskActions.ts with status-to-action mapping and real Supabase updateTaskStatus function, integrate into TaskCard and TaskDetailScreen primary button handlers.",
            "dependencies": [
              1
            ],
            "details": "Implement exact code structure from notes: TaskStatus type, PrimaryAction type, primaryActionForStatus record, async updateTaskStatus using supabase.from('tasks').update(). Integrate in button onPress handlers with visual feedback within 100ms using pressed state.",
            "status": "done",
            "testStrategy": "Unit tests for primaryActionForStatus mapping and updateTaskStatus error handling; mock Supabase integration tests.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrate Flagsmith feature flag gating and backward compatibility",
            "description": "Gate new single-tap flow behind flags.prepchef_single_tap_flow, preserve legacy multi-button flows when flag off, ensure SSR compatibility by gating APIs in useEffect.",
            "dependencies": [
              2
            ],
            "details": "Use existing Flagsmith SDK, conditional rendering of primary button vs legacy buttons. Gate Supabase calls behind flag and useEffect/dynamic imports (ssr: false if needed). Maintain data/workflow compatibility.",
            "status": "done",
            "testStrategy": "Integration tests toggling flag on/off verifying correct UI and no regressions; SSR hydration mismatch checks.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add comprehensive tests and performance validation for 100ms feedback",
            "description": "Implement unit/integration tests for components and APIs, validate interaction latency, confirm WCAG touch targets and state transitions meet acceptance criteria.",
            "dependencies": [
              3
            ],
            "details": "Unit tests: taskActions.test.ts for mapping/API. Integration: React Native Testing Library for TaskCard/TaskDetailScreen verifying single primary action, correct transitions. Performance: measure pressed state render time on devices. Axe tests for accessibility.",
            "status": "done",
            "testStrategy": "Automated: jest-axe for violations, RNTL for interactions, performance profiling. Manual: 44px hit verification, 100ms feedback on kitchen tablets, Flagsmith toggle validation.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into subtasks: 1) Audit and update touch targets to 44px across TaskListScreen, TaskDetailScreen, TaskCard; 2) Implement primaryActionForStatus state machine and Supabase integration; 3) Integrate feature flag gating and backward compatibility; 4) Add unit/integration tests and performance validation for 100ms feedback.",
        "updatedAt": "2025-12-19T04:43:15.442Z"
      },
      {
        "id": "12",
        "title": "Implement PrepChef toast notifications with undo support and real-time backend integration",
        "description": "Add a unified toast feedback system to PrepChef mobile with undo functionality for key actions, fully integrated with the Supabase backend and feature flags for safe rollout.",
        "details": "Owner: @business-logic (primary), @ui-ux\nComplexity: 6/10\n\nScope & Files:\n- Target feedback/notification layer in `apps/prepchef-mobile/`, e.g. `providers/ToastProvider.tsx`, `hooks/useToast.ts`, `components/Toast.tsx`.\n- Integrate with task actions and other critical flows (e.g. task completion, cancellation).\n\nFunctional Requirements:\n- Show non-blocking **toast messages** for user actions (task status changes, errors, network issues) with succinct descriptions.\n- For reversible actions (e.g. marking a task as completed), provide an **Undo** affordance within the toast for a limited time window (e.g. 5–10 seconds).\n- Undo must be **fully backed by Supabase**: the system must revert the previous change in the database, not just in local UI state.\n- Preserve current API contracts and data model; do not add breaking changes.\n- Ensure no simulated (client-only) operations remain for the supported flows.\n\nImplementation Notes:\n- Prefer using any existing notification components from `@codemachine/ui` (e.g. `Toast`, `Banner`) and extend them if necessary in `@codemachine/ui` instead of forking new patterns.\n- Implement a ToastContext with API like:\n```ts\n// apps/prepchef-mobile/providers/ToastProvider.tsx\nexport interface ToastOptions {\n  id?: string;\n  message: string;\n  type?: 'success' | 'error' | 'info';\n  actionLabel?: string; // e.g. 'Undo'\n  onAction?: () => Promise<void> | void;\n  durationMs?: number;\n}\n\nconst ToastContext = createContext<{ showToast: (opts: ToastOptions) => void } | null>(null);\n```\n- Wire `showToast` into task action handlers (from Task 11). Example pattern:\n```ts\nasync function onPrimaryActionPress(task: Task) {\n  const prevStatus = task.status;\n  const action = primaryActionForStatus[task.status];\n  try {\n    const updated = await updateTaskStatus(task.id, action.nextStatus);\n    showToast({\n      message: `Task ${action.label.toLowerCase()}ed`,\n      type: 'success',\n      actionLabel: 'Undo',\n      onAction: async () => {\n        await updateTaskStatus(task.id, prevStatus);\n      },\n      durationMs: 8000,\n    });\n  } catch (e) {\n    showToast({ message: 'Failed to update task', type: 'error' });\n  }\n}\n```\n- Use Flagsmith flag, e.g. `prepchef_toast_undo`, to enable/disable undo functionality without removing the base toast system.\n- Ensure the component tree remains SSR-compatible; do not access `window` at module top-level.\n\nAccessibility & Performance:\n- Ensure toast is announced to assistive technologies using ARIA live regions (for web builds) or platform-specific accessibility announcements for native.\n- Keep the toast rendering lightweight; limit the number of concurrent toasts and cap updates per second.\n\nAcceptance Criteria:\n- Successful actions surface a toast within 200ms of completion, describing the outcome.\n- Undo is available for at least all task status changes that are reversible and correctly reverts backend state on Supabase.\n- No simulated state-only undos; database reflects final state after undo or timer expiry.\n- Feature is controllable via Flagsmith and is fully backward compatible when disabled.\n- Toast appearance and interaction patterns are consistent with the design system guidelines.",
        "testStrategy": "Owner: @qa-automation\n\nAutomated Tests:\n- Unit tests for ToastContext and `useToast` hook in `apps/prepchef-mobile/providers/__tests__/ToastProvider.test.tsx`:\n  - Verify that calling `showToast` renders a toast with correct message and type.\n  - Simulate clicking the `Undo` action and assert that the provided `onAction` callback is called.\n- Integration tests for task undo behavior:\n  - Mock Supabase `updateTaskStatus` and assert that it is called first with `nextStatus` and then with `prevStatus` when undo is activated.\n\nManual Tests:\n- In PrepChef on a test device, trigger each primary action (start/pause/resume/complete) and confirm a toast appears with expected text and an Undo button where applicable.\n- Trigger multiple actions in quick succession to ensure toasts stack or replace each other gracefully and do not block core UI.\n- Use assistive technology (screen reader) to confirm that toast content is announced.\n\nRegression & Performance:\n- Confirm that enabling/disabling `prepchef_toast_undo` via Flagsmith does not cause runtime errors and that base flows still work.\n- Monitor for dropped frames when many toasts appear; verify no perceivable impact on scrolling or tap responsiveness.\n- Run a short UAT session with at least 3 kitchen staff to validate that the feedback and undo behavior are clear and useful; capture issues for subsequent fixes.",
        "priority": "high",
        "dependencies": [
          "11"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement ToastContext, Provider, and base toast UI with undo-capable actions",
            "description": "Create a shared ToastContext/Provider in apps/prepchef-mobile that exposes a showToast API with undo-capable actions, backed by existing @codemachine/ui toast components.",
            "dependencies": [],
            "details": "1) Add ToastOptions interface and ToastContext to apps/prepchef-mobile/providers/ToastProvider.tsx matching the specified API (message, type, actionLabel, onAction, durationMs, optional id). 2) Implement ToastProvider that manages a small in-memory queue of active toasts, handles auto-dismiss via timers, and renders a toast list using existing @codemachine/ui components (e.g. Toast/Banner) or minimal wrappers in apps/prepchef-mobile/components/Toast.tsx. 3) Ensure onAction supports async functions and that the toast UI disables the action button while the undo action is running and handles errors (e.g. show error toast). 4) Create a hooks/useToast.ts hook that reads ToastContext and throws or no-ops if used outside the provider. 5) Ensure SSR-compatibility by avoiding window access at module top-level and only interacting with timers/effects inside React hooks. 6) Keep the visual design aligned with design system tokens (colors, typography, spacing) and support basic variants for success, error, and info.",
            "status": "done",
            "testStrategy": "Add unit tests in apps/prepchef-mobile/providers/__tests__/ToastProvider.test.tsx to verify that: (a) calling showToast renders a toast with the provided message and type, (b) toasts auto-dismiss after durationMs, (c) passing an actionLabel and onAction wires the button and triggers onAction on press, including proper handling of async promises and error paths.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Wire toast notifications with Supabase-backed undo into task action handlers",
            "description": "Connect the toast system to task action handlers so that task status changes and related flows surface toasts with Supabase-backed undo that reverts the backend state.",
            "dependencies": [
              1
            ],
            "details": "1) In task action handlers implemented for Task 11 (e.g. in apps/prepchef-mobile/domain/taskActions and UI components like TaskCard, TaskDetailScreen, PrimaryActionButton), inject useToast and call showToast on successful Supabase-backed status changes. 2) Follow the provided onPrimaryActionPress pattern: capture prevStatus, execute updateTaskStatus(task.id, action.nextStatus), then display a success toast with an Undo action that calls updateTaskStatus(task.id, prevStatus) using the same Supabase API, ensuring no client-only simulated state remains. 3) Ensure all reversible task status transitions (e.g. completed, cancelled, started) use the undo pattern, while irreversible actions omit undo. 4) Handle failures by showing error toasts when updateTaskStatus or undo fails, preserving existing API contracts and models. 5) Confirm final task state always matches Supabase after either undo execution or toast timeout expiry, and that no stale optimistic-only state persists in the UI.",
            "status": "done",
            "testStrategy": "Extend existing tests in apps/prepchef-mobile/domain/__tests__/taskActions.test.ts and relevant component tests to: (a) mock updateTaskStatus and verify success toasts are shown on completion, (b) simulate tapping Undo and assert updateTaskStatus is called with the previous status, (c) verify that when undo fails, an error toast is displayed and the task state reflects the backend outcome.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add accessibility, feature-flag control, tests, and performance limits for toast undo system",
            "description": "Implement ARIA/accessibility behavior, Flagsmith-based undo gating, automated tests, and safeguards for concurrent toast performance in the PrepChef toast system.",
            "dependencies": [
              1,
              2
            ],
            "details": "1) Integrate Flagsmith flag (e.g. prepchef_toast_undo) so that undo actions and UI are conditionally enabled while the base toast notifications remain available when the flag is off; ensure backward compatibility and safe rollout paths. 2) For web builds, ensure toasts are exposed via ARIA live regions (e.g. role=\"status\" or aria-live=\"polite\"/\"assertive\" as appropriate), and for native builds use platform-specific accessibility announcements so screen readers receive toast messages. 3) Add limits on the number of concurrent visible toasts (e.g. max N stacked toasts, dropping or merging extras) and ensure timer and state updates are throttled to avoid excessive re-renders. 4) Validate that toast appearance and interaction patterns match design system guidelines (spacing, motion, colors) and remain consistent across platforms. 5) Confirm no SSR issues are introduced by feature flag checks or accessibility hooks (e.g. guard against window/document usage at module scope).",
            "status": "done",
            "testStrategy": "Add automated tests to cover: (a) feature-flag behavior where prepchef_toast_undo off hides Undo affordances but still shows success/error toasts, (b) ARIA live attributes are present in web snapshots using React Testing Library and jest-axe to ensure no critical accessibility violations for toast markup, and (c) performance constraints such as enforcing a cap on the number of rendered toasts and verifying that adding more toasts beyond the limit does not increase the rendered count.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Divide into subtasks: 1) Create ToastContext/Provider with undo action support using existing UI components; 2) Integrate toasts into task action handlers with Supabase-backed undo logic; 3) Add accessibility (ARIA live), feature flags, tests, and performance checks for concurrent toasts."
      },
      {
        "id": "13",
        "title": "Implement cross-platform WCAG 2.1 AA accessibility baseline (keyboard, focus, ARIA)",
        "description": "Establish a shared accessibility layer and patterns to achieve WCAG 2.1 AA compliance across PrepChef, Admin CRM, and Display, focusing on keyboard navigation, focus management, and ARIA semantics.",
        "details": "Owner: @ui-ux (primary), @business-logic\nComplexity: 8/10\n\nScope & Files:\n- Shared UI library: `packages/@codemachine/ui/` (buttons, inputs, dialogs, modals, lists, toasts, DnD).\n- App-level accessibility configs:\n  - `apps/admin-crm-web/` (web dashboard).\n  - `apps/display-kiosk/` (kiosk web app).\n  - `apps/prepchef-mobile/` web/native bridges as applicable.\n\nFunctional Requirements:\n- Ensure **full keyboard navigation** on web apps (Admin CRM, Display) for all interactive elements.\n- Implement consistent **focus management**: visible focus indicators, logical tab order, and focus trapping in modals/overlays.\n- Add missing **ARIA labels/roles** to interactive components and status messages.\n- Integrate automated accessibility testing (axe-core) into CI (high-level wiring; detailed testing suite in Task 20 analog later, partially here).\n\nImplementation Notes:\n- In `@codemachine/ui`:\n  - Update `Button`, `IconButton`, `Link`, `Input`, `Checkbox`, `Select`, `Dialog`, etc. to:\n    - Forward `aria-*` props.\n    - Ensure correct `role` and `tabIndex` (default 0 for interactive elements not naturally focusable).\n    - Provide visible `:focus-visible` styles using design tokens.\n- Implement a `FocusScope` or reuse an existing one to trap focus inside modals/drawers.\n- Provide helper components/hooks, e.g. `useAriaLive`:\n```ts\n// packages/@codemachine/ui/src/hooks/useAriaLive.tsx\nexport function useAriaLive(regionId = 'cm-aria-live') {\n  const [message, setMessage] = useState('');\n  // Render a visually hidden live region at app root via a provider.\n  return { announce: setMessage };\n}\n```\n- For Admin CRM pages (e.g. `apps/admin-crm-web/pages/**/*.tsx`):\n  - Ensure headings follow a proper hierarchy (h1, h2, h3).\n  - Ensure landmark roles (`main`, `nav`, `header`, `footer`) are present.\n  - Audit all forms to ensure labels are linked to inputs (`htmlFor`/`id` and `aria-labelledby`).\n- For Display kiosk:\n  - Ensure kiosk elements that are interactive or informational for assistive tech have correct roles and labels, even if typically touch-only.\n- Introduce axe-core checks in web test setup, e.g. `apps/admin-crm-web/tests/accessibility.test.ts` using `jest-axe`.\n\nAcceptance Criteria:\n- All web UI components used in Admin CRM and Display are keyboard focusable and operable (no mouse-only interactions).\n- Visible focus indicator meets contrast and visibility expectations across themes.\n- Screen readers correctly announce:\n  - Link and button labels.\n  - Form field labels and error messages.\n  - Toasts and status messages via aria-live.\n- axe-core baseline scans on key flows show no critical violations and pass at least 95% WCAG 2.1 AA checks by count.\n- No degradation in performance greater than 5% in measured page load or interaction timing metrics.",
        "testStrategy": "Owner: @qa-automation\n\nAutomated Tests:\n- Add `jest-axe` tests for representative pages/components in Admin CRM and Display (e.g. dashboard page, main kiosk screen) ensuring `expect(await axe(container)).toHaveNoViolations()` for critical violations.\n- Add unit tests in `@codemachine/ui` verifying that:\n  - `Button` forwards `aria-label` and `aria-describedby`.\n  - `Dialog` correctly traps focus and restores it on close.\n\nManual Tests:\n- Keyboard-only walkthroughs on Admin CRM and Display:\n  - Verify tab/shift+tab order is logical and cyclical in modals.\n  - Confirm that all functionality is available without a mouse.\n- Screen reader passes (NVDA/JAWS/VoiceOver) on:\n  - Admin CRM main dashboard.\n  - At least one critical data entry form.\n  - Main kiosk display screen.\n\nRegression & Performance:\n- Run Lighthouse accessibility audits on key pages and capture scores; confirm >=95 for accessibility.\n- Use browser devtools performance panel to verify that added accessibility props/styles do not introduce noticeable layout thrash or script overhead.\n- Ensure SSR output remains valid HTML with correct ARIA attributes and no hydration warnings.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Update shared @codemachine/ui components with ARIA and focus props",
            "description": "Enhance UI components like Button, Input, Dialog, etc., to forward aria-* props, set correct roles/tabIndex, and add visible :focus-visible styles using design tokens.",
            "dependencies": [],
            "details": "Target packages/@codemachine/ui/src/components/ (Button, IconButton, Link, Input, Checkbox, Select, Dialog, etc.). Ensure tabIndex=0 for interactive elements, forwardRef for aria props, and CSS focus styles meeting WCAG contrast. Update TypeScript interfaces to include aria props.",
            "status": "done",
            "testStrategy": "Add unit tests with jest-axe for each updated component: render with aria-label and assert no violations; test focus styles with @testing-library/react.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement focus trapping and management for modals and overlays",
            "description": "Create or enhance FocusScope component/hook to trap focus inside modals, drawers, and overlays, ensuring logical tab order and escape key handling.",
            "dependencies": [
              1
            ],
            "details": "In packages/@codemachine/ui/src/components/FocusScope.tsx or hooks/useFocusTrap.ts. Use roving tabindex or focus management libs if available; ensure :focus-visible indicators; handle Shift+Tab wraparound.",
            "status": "done",
            "testStrategy": "E2E tests simulating Tab/Shift+Tab navigation in modals; verify focus doesn't escape; test with keyboard-only navigation using Playwright or Cypress.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Apply app-level accessibility fixes for Admin CRM and Display apps",
            "description": "Audit and fix headings hierarchy, add landmark roles (main, nav), link form labels to inputs, and ensure ARIA for kiosk elements in Admin CRM and Display.",
            "dependencies": [
              1
            ],
            "details": "Update apps/admin-crm-web/pages/**/*.tsx for h1-h6 order, <main role='main'>, htmlFor/id on labels. For apps/display-kiosk/, add roles/labels to interactive/info elements despite touch-primary.",
            "status": "done",
            "testStrategy": "Run axe-core scans on key pages (e.g., dashboard); manual keyboard tab through pages verifying logical order; screen reader tests with NVDA/VoiceOver.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate axe-core and jest-axe into CI and test setups",
            "description": "Wire automated accessibility testing with axe-core into web app CI pipelines and create baseline tests for representative pages/components.",
            "dependencies": [
              1,
              3
            ],
            "details": "Add jest-axe to apps/admin-crm-web/tests/accessibility.test.ts and apps/display-kiosk/; configure in package.json/jest.config.js; run on PRs via turbo/CI; target 95% pass rate.",
            "status": "done",
            "testStrategy": "Assert expect(await axe(container)).toHaveNoViolations() in tests; monitor CI failures; baseline critical violations only initially.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Develop aria-live helpers and conduct manual accessibility testing",
            "description": "Implement useAriaLive hook for toasts/status messages; perform comprehensive keyboard, screen reader, and WCAG validation across all apps.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create packages/@codemachine/ui/src/hooks/useAriaLive.tsx as specified; test announcements for toasts/errors. Manual: full keyboard flows, NVDA/JAWS/VoiceOver on buttons/forms/modals, focus indicator contrast checks.",
            "status": "done",
            "testStrategy": "Manual verification checklist: keyboard operability, screen reader announcements (e.g., button labels, errors), focus visibility across themes; document passes/fails in report.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Expand into subtasks: 1) Update shared @codemachine/ui components (Button, Dialog, etc.) with ARIA/focus props; 2) Implement focus trapping and management in modals/overlays; 3) Add app-level fixes for Admin CRM and Display (headings, landmarks); 4) Integrate axe-core/jest-axe into CI/tests; 5) Manual screen reader and keyboard testing across apps."
      },
      {
        "id": "14",
        "title": "Enhance Display kiosk typography, density, and high-contrast theme for distance readability",
        "description": "Redesign the Display kiosk UI to be legible from 6–10 feet with a kiosk-specific typography scale, reduced visual density, and a high-contrast mode while maintaining 60fps performance.",
        "details": "Owner: @ui-ux\nComplexity: 7/10\n\nScope & Files:\n- Kiosk app: `apps/display-kiosk/`.\n- Shared tokens & themes: `packages/@codemachine/ui/tokens/`, `packages/@codemachine/ui/theme/`.\n\nFunctional Requirements:\n- Define a **kiosk typography scale** with font sizes and line heights that are readable from 6–10 feet.\n- Reduce information density to prioritize key information (e.g. current orders, status) with sufficient spacing.\n- Implement a **high-contrast mode** toggle that significantly increases contrast between foreground and background.\n- Ensure kiosk maintains 60fps under typical operational loads.\n\nImplementation Notes:\n- Extend design tokens for typography:\n```ts\n// packages/@codemachine/ui/tokens/typography.ts\nexport const typography = {\n  kioskHeading: { fontSize: 32, lineHeight: 40 },\n  kioskSubheading: { fontSize: 24, lineHeight: 32 },\n  kioskBody: { fontSize: 20, lineHeight: 28 },\n};\n```\n- In `apps/display-kiosk/components/OrderList.tsx` and main screen components, apply kiosk typography tokens and increased spacing using layout tokens.\n- Simplify layouts to avoid overly dense tables; prefer large rows/cards with clear status indicators.\n- Implement a `kioskHighContrast` theme variant in `@codemachine/ui/theme/` with WCAG AA-compliant color pairs.\n- Add a kiosk-level toggle (feature flag + runtime toggle in admin UI) to switch between default and high-contrast themes, e.g. via context or existing theming hooks.\n- Avoid heavy animations; use simple CSS transitions if needed and keep DOM node count reasonable for 60fps.\n\nAcceptance Criteria:\n- Main kiosk screen text (headings and primary data) is readable from at least 8 feet in a controlled test.\n- High-contrast mode yields contrast ratios meeting or exceeding WCAG 2.1 AA thresholds for text and UI components.\n- Kiosk app scrolls and updates at or near 60fps on target kiosk hardware during simulated busy periods.\n- Typography and spacing changes are implemented via shared tokens so they can be reused and managed centrally.",
        "testStrategy": "Owner: @qa-automation\n\nManual Tests:\n- Conduct a distance readability test: open the main kiosk screens on a kiosk display and verify that core information (order number, status, timing) is readable and distinguishable at 8–10 feet for multiple testers.\n- Verify high-contrast mode:\n  - Toggle on and off and confirm all screens update colors correctly.\n  - Use color contrast analysis tools to confirm AA compliance.\n\nAutomated / Performance Tests:\n- Use browser performance profiling on kiosk screens under load (simulated frequent order updates) and verify frame rate is ~60fps with no long tasks >50ms.\n- Add visual regression tests (e.g. via Storybook + screenshot testing) for default vs high-contrast themes to prevent accidental regressions.\n\nAccessibility Tests:\n- Run axe-core on kiosk screens to ensure the new theme and typography do not introduce accessibility violations.\n- Verify that contrast ratios remain compliant in both light and high-contrast themes.",
        "priority": "high",
        "dependencies": [
          "13"
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Define kiosk-specific typography and layout tokens",
            "description": "Create and extend design tokens in @codemachine/ui for kiosk typography scale (font sizes/line heights readable from 6-10ft) and increased spacing to reduce density, based on kiosk UX best practices for large, legible fonts and ample whitespace.",
            "dependencies": [],
            "details": "Update packages/@codemachine/ui/tokens/typography.ts with kioskHeading (32px/40lh), kioskSubheading (24px/32lh), kioskBody (20px/28lh); add layout tokens for spacing (e.g. kioskSpacingLarge: 24px). Ensure tokens support distance readability per WCAG and kiosk guidelines[1][3][7].",
            "status": "done",
            "testStrategy": "Validate token values against readability specs; visual regression tests on token application; manual check for legibility simulation at 8ft.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Refactor Display kiosk screens using new tokens and reduce density",
            "description": "Apply kiosk typography/layout tokens to OrderList.tsx and main screens in apps/display-kiosk/; simplify layouts to large rows/cards prioritizing key info (orders/status) with reduced density and sufficient spacing.",
            "dependencies": [
              1
            ],
            "details": "Replace dense tables with spacious cards/rows using kiosk tokens; increase padding/margins via layout tokens; remove non-essential elements per simplicity best practices[1][2][4]. Keep DOM lightweight for perf.",
            "status": "done",
            "testStrategy": "UI review for density reduction; distance readability test at 8-10ft; measure DOM node count and layout shift.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement high-contrast theme toggle with WCAG validation and perf testing",
            "description": "Add kioskHighContrast theme variant in @codemachine/ui/theme/ with WCAG AA colors; implement runtime toggle via context/feature flag; ensure 60fps under load with simple transitions.",
            "dependencies": [
              1,
              2
            ],
            "details": "Define high-contrast colors meeting WCAG 2.1 AA (contrast >=4.5:1); add admin UI toggle; test perf on kiosk hardware during busy simulations; avoid heavy animations[1][3][5].",
            "status": "done",
            "testStrategy": "Automated contrast ratio checks (e.g. axe-core); 60fps profiling with React DevTools/Chrome perf; toggle functionality E2E tests; manual WCAG validation.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Split into: 1) Define kiosk-specific typography/layout tokens in @codemachine/ui; 2) Refactor Display kiosk screens to use tokens and reduce density; 3) Implement high-contrast theme toggle with WCAG validation and 60fps performance testing."
      },
      {
        "id": "15",
        "title": "Build Admin CRM operations dashboard with accessible KPIs and bulk operations",
        "description": "Create a comprehensive Admin CRM dashboard that surfaces key kitchen KPIs with clear hierarchy and supports accessible bulk operations on entities (e.g. orders, tasks).",
        "details": "Owner: @business-logic (primary), @ui-ux\nComplexity: 8/10\n\nScope & Files:\n- Admin CRM web app: `apps/admin-crm-web/pages/dashboard.tsx` (or feature module), `components/dashboard/`.\n- Shared UI: `@codemachine/ui` for cards, charts, tables, bulk action bars.\n\nFunctional Requirements:\n- Display primary **operational KPIs** (e.g. orders in progress, average prep time, overdue items, station load) in a clear, prioritized layout.\n- Provide **bulk operations** (e.g. assign, reassign, change status) on relevant resources with proper confirmation and accessibility.\n- Ensure drag-and-drop (DnD) interactions, if used (e.g. reassigning tasks), are accessible and keyboard-operable.\n\nImplementation Notes:\n- Design dashboard layout with sections:\n  - KPI summary row using cards: `KpiCard` component.\n  - Detailed lists/tables for actionable items.\n- Use Supabase queries (respecting existing schema and RLS policies) to fetch KPIs. Example pseudo-query:\n```ts\nconst { data: orders } = await supabase\n  .from('orders')\n  .select('id,status,created_at,completed_at,station_id');\n// Compute metrics in the app or via existing views.\n```\n- Implement `KpiCard` in `@codemachine/ui` if not existing, accepting aria attributes and focus states for keyboard users.\n- For bulk operations:\n  - Use a table or list with checkboxes to select multiple rows.\n  - Provide bulk action bar that appears when one or more items are selected.\n  - Ensure all interactions are available via keyboard and labeled appropriately.\n- For DnD accessibility:\n  - Use or extend any existing DnD utility that supports keyboard navigation.\n  - Provide alternative controls (e.g. dropdowns) to perform equivalent actions without drag-and-drop.\n\nAcceptance Criteria:\n- Dashboard shows at least 3–5 key KPIs, updated in near real time (on refresh or short polling/WS if already present in the system) based on live Supabase data.\n- Bulk operations can be performed on at least one resource type, validated on backend and respecting existing API contracts.\n- Keyboard users can:\n  - Navigate all KPI cards and lists.\n  - Select and operate bulk actions.\n  - Access an alternative to DnD where necessary.\n- Visual hierarchy clearly emphasizes the most important metrics and actions as determined by product/design.",
        "testStrategy": "Owner: @qa-automation\n\nAutomated Tests:\n- Unit/integration tests for `KpiCard` and bulk action components to validate keyboard interaction, ARIA attributes, and selection logic.\n- API integration tests (or contract tests) ensuring that bulk action endpoints are invoked with correct payloads and handle RLS constraints gracefully.\n\nManual Tests:\n- Verify that the dashboard loads KPIs correctly for different roles (e.g. manager vs staff) respecting existing authentication/authorization.\n- Perform bulk operations via mouse and keyboard only, confirming updates persist in Supabase and are reflected in subsequent views.\n- Validate that an equivalent, non-DnD interaction path exists for any DnD-based operation.\n\nAccessibility & UX Tests:\n- Run axe-core scans on the dashboard page to confirm no high-severity issues.\n- Conduct heuristic evaluation with at least one UX reviewer focusing on information hierarchy and clarity.\n- Confirm that focus order through KPI cards and bulk action controls matches visual order and user expectations.",
        "priority": "medium",
        "dependencies": [
          "13"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and implement KPI cards and dashboard layout with Supabase queries",
            "description": "Create the KPI summary row using KpiCard components and detailed lists/tables, integrating Supabase queries for real-time operational KPIs like orders in progress and average prep time.",
            "dependencies": [],
            "details": "Implement in apps/admin-crm-web/pages/dashboard.tsx and components/dashboard/. Use @codemachine/ui for cards. Fetch data via Supabase respecting RLS, compute metrics client-side. Ensure prioritized layout with visual hierarchy per best practices[1][2][4].",
            "status": "pending",
            "testStrategy": "Unit tests for KpiCard rendering and Supabase query integration; validate KPI calculations against sample data.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Build accessible bulk operations with checkboxes and action bar",
            "description": "Implement bulk operations for resources like orders and tasks, including selection checkboxes, bulk action bar, and confirmation dialogs.",
            "dependencies": [
              1
            ],
            "details": "Add table/list with checkboxes in dashboard components. Show action bar on selection for assign/reassign/status change. Use shared UI from @codemachine/ui. Ensure keyboard navigation and ARIA labels for accessibility.",
            "status": "pending",
            "testStrategy": "Integration tests for selection logic, bulk API calls, and keyboard operability using axe-core.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add keyboard and DnD alternatives for full WCAG compliance",
            "description": "Ensure all interactions including drag-and-drop are keyboard operable, with alternative controls like dropdowns for reassigning tasks.",
            "dependencies": [
              1,
              2
            ],
            "details": "Extend DnD utilities for keyboard support. Add ARIA attributes to KpiCard and bulk components. Provide non-DnD alternatives. Test with high contrast and screen readers.",
            "status": "pending",
            "testStrategy": "Axe-core scans, keyboard navigation tests, and manual WCAG 2.1 AA checks for focus management.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Conduct integration tests, axe-core scans, and role-based validation",
            "description": "Run comprehensive tests including unit/integration, accessibility scans, and validate data with RLS policies.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Cover KpiCard, bulk actions, keyboard/DnD. Test backend validation for bulk ops. Verify role-based data visibility and near real-time updates via polling/WS.",
            "status": "pending",
            "testStrategy": "Automated e2e tests with Playwright/Cypress; API contract tests; RLS policy enforcement checks.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Decompose to: 1) Design/implement KPI cards and dashboard layout with Supabase queries; 2) Build accessible bulk operations (checkboxes, action bar); 3) Add keyboard/DnD alternatives ensuring WCAG compliance; 4) Integration tests, axe-core scans, and role-based data validation."
      },
      {
        "id": "16",
        "title": "Standardize design tokens and shared components in @codemachine/ui",
        "description": "Create a unified design token system and shared component library updates in @codemachine/ui to",
        "status": "pending",
        "priority": "medium",
        "dependencies": [],
        "subtasks": [
          {
            "id": 1,
            "title": "Audit existing tokens and components for inconsistencies",
            "description": "Conduct a comprehensive audit of current design tokens and shared components in @codemachine/ui to identify inconsistencies, duplicates, and gaps across colors, typography, spacing, and components.",
            "dependencies": [],
            "details": "Review packages/@codemachine/ui/tokens/, components/, and usage in apps like admin-crm-web, display-kiosk, prepchef-mobile. Document findings in a report with examples of inconsistencies like varying color values or spacing units. Use tools like grep or linters for code search.",
            "status": "pending",
            "testStrategy": "Manual review: Cross-check audit report against code samples from dependent apps (Task 15,14,11); validate with team stakeholders.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Define unified typography, color, and spacing tokens",
            "description": "Create a standardized set of design tokens for typography scales, color palette, and spacing system following semantic naming conventions like category.concept.property.",
            "dependencies": [
              1
            ],
            "details": "Base on audit results and project needs (kiosk readability from Task 14, WCAG touch targets from Task 11, high-contrast modes). Use JSON format compatible with W3C spec, ensure accessibility (WCAG AA contrast). Examples: color.background.primary, spacing.inset.medium, typography.heading.kiosk.",
            "status": "pending",
            "testStrategy": "Automated: Build script to validate token references and contrast ratios; manual: Visual diff in Figma/Storybook against audit findings.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Refactor and update key shared components to use new tokens",
            "description": "Update critical shared UI components in @codemachine/ui (e.g. cards, charts, tables, buttons) to consume the new unified design tokens, removing hardcoded values.",
            "dependencies": [
              2
            ],
            "details": "Prioritize components used in dependent tasks: KPI cards/bulk actions (Task 15), kiosk typography/themes (Task 14), touch targets (Task 11). Use CSS custom properties or Tailwind for token integration. Handle themes like high-contrast mode.",
            "status": "pending",
            "testStrategy": "Unit tests for component rendering with tokens; integration tests in Storybook; visual regression tests pre/post refactor.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add documentation, Storybook stories, and regression tests",
            "description": "Document the new token system and updated components, enhance Storybook with interactive examples, and implement tests to prevent regressions.",
            "dependencies": [
              3
            ],
            "details": "Create README.md with token overview, usage guidelines, code snippets per best practices. Add Storybook pages for tokens/components with controls for themes. Include accessibility audits. Publish to Storybook for team review.",
            "status": "pending",
            "testStrategy": "E2E tests simulating app usage (e.g. dashboard KPIs, kiosk screens); Storybook test runner for component isolation; manual accessibility scan with Lighthouse.",
            "parentId": "undefined"
          }
        ],
        "details": "",
        "testStrategy": "",
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into: 1) Audit existing tokens/components for inconsistencies; 2) Define unified typography/color/spacing tokens; 3) Refactor/update key shared components to use new tokens; 4) Add documentation, Storybook updates, and regression tests."
      },
      {
        "id": "17",
        "title": "Implement Playwright WCAG 2.1 AA Accessibility Test Suite Across All Apps",
        "description": "Create a comprehensive Playwright test suite using axe-core to validate WCAG 2.1 AA compliance, keyboard navigation, screen reader compatibility, and performance metrics for touch targets and response times across PrepChef, Admin CRM, and Display applications.",
        "details": "Develop a dedicated Playwright test suite in `packages/e2e-tests/` targeting WCAG 2.1 AA compliance across all three applications using current best practices from Playwright documentation and axe-core integration[1][4].\n\n**Setup and Configuration:**\n- Install dependencies: `npm install --save-dev @playwright/test @axe-core/playwright @axe-core/react` (for React components)[1][3][4].\n- Configure `playwright.config.ts` with projects for each app:\n  ```typescript\n  projects: [\n    { name: 'prepchef-mobile', use: { ...devices['iPhone 14'] } },\n    { name: 'admin-crm-web', use: { viewport: { width: 1280, height: 720 } } },\n    { name: 'display-kiosk', use: { viewport: { width: 1920, height: 1080 } } }\n  ]\n  ```\n- Add axe-core ruleset: `{ runOnly: { type: 'tag', values: ['wcag2a', 'wcag2aa'] } }` for WCAG 2.1 AA focus[2][4].\n\n**Core Test Coverage:**\n1. **Axe-core Automated Scans** (`tests/accessibility/axe-scans.spec.ts`):\n   - Full-page scans on critical paths: login, dashboard, task lists, task details[1][4].\n   ```typescript\nimport { test, expect } from '@playwright/test';\nimport AxeBuilder from '@axe-core/playwright';\n\ntest.describe('Admin CRM Accessibility', () => {\n  test('dashboard should pass WCAG 2.1 AA', async ({ page }) => {\n    await page.goto('/dashboard');\n    const results = await new AxeBuilder({ page })\n      .withTags(['wcag2a', 'wcag2aa'])\n      .analyze();\n    expect(results.violations).toEqual([]);\n  });\n});\n   ```\n   - Component-level scans for shared UI from `@codemachine/ui`[3].\n\n2. **Keyboard Navigation Tests** (`tests/accessibility/keyboard.spec.ts`):\n   - Tab through all interactive elements verifying logical focus order[3][4].\n   - Test `Tab`, `Shift+Tab`, `Enter`, `Space`, `Escape` on buttons, forms, modals.\n   - Skip links and focus management verification per Task 13 patterns.\n   ```typescript\n   await page.keyboard.press('Tab');\n   await expect(page.locator(':focus')).toBeVisible();\n   ```\n\n3. **Screen Reader Compatibility** (`tests/accessibility/screenreader.spec.ts`):\n   - Verify ARIA landmarks, labels, roles using Playwright's `getByRole()`[4].\n   - Test live regions (toasts from Task 12) announce correctly.\n   - Validate `aria-live`, `role='status'`, `role='alert'` on dynamic content.\n\n4. **Touch Target & Performance Tests** (`tests/accessibility/performance.spec.ts`):\n   - Verify 44px minimum touch targets (build on Task 11): `expect(button.boundingBox()).width >= 44`[11].\n   - Response time assertions: `await expect(page.locator('button')).toBeEnabled({ timeout: 300 });`.\n   - Kiosk-specific distance readability checks for Task 14 high-contrast mode.\n\n**App-Specific Coverage:**\n- **PrepChef Mobile**: Task flows, single-tap actions (Task 11), toast notifications (Task 12).\n- **Admin CRM**: Dashboard KPIs (Task 15), bulk operations.\n- **Display Kiosk**: Main screens, high-contrast theme (Task 14).\n\n**Integration Points:**\n- Leverage shared accessibility baseline from Task 13.\n- Use design tokens from Task 16 for consistent testing selectors.\n- CI/CD integration: Run on every PR with `npx playwright test --project=accessibility`.\n\n**Best Practices:**\n- Exclude third-party embeds from scans using `exclude: ['[data-skip-a11y]']`[1].\n- Generate HTML reports: `npx playwright show-report`.\n- Thresholds: Fail on violations, warn on 'needsReview'[2].",
        "testStrategy": "Execute comprehensive verification across multiple dimensions to ensure WCAG 2.1 AA compliance and performance standards[1][3][4].\n\n**Automated Test Execution:**\n- Run full suite: `npx playwright test --project=accessibility` expecting 0 axe-core violations on WCAG 2A/2AA rules.\n- Verify axe reports: `expect(accessibilityScanResults.violations).toEqual([])` for all critical pages[1][4][5].\n- Keyboard tests: Confirm 100% tab coverage reaches all interactive elements without trapping; validate focus indicators visible.\n- Screen reader: Assert all interactive elements have `getByRole()` selectors; live regions announce within 1s.\n- Touch/performance: All buttons/links ≥44px; interactions complete <500ms; kiosk text readable at 1920x1080 scale.\n\n**Manual Validation Checklist:**\n- NVDA/JAWS screen reader: Navigate complete user flows on Admin CRM/Display (verify Task 13 ARIA implementation).\n- VoiceOver (iOS): Test PrepChef mobile task flows (Task 11 single-tap, Task 12 toasts).\n- Distance test: Display kiosk screens legible at 8-10ft (Task 14 high-contrast).\n- Color contrast analyzer on screenshots from high-contrast mode.\n\n**CI/CD Verification:**\n- GitHub Actions: Fail PRs with accessibility violations; post axe-core HTML report as artifact.\n- Coverage report: ≥95% critical path coverage across all three apps.\n- Regression check: Re-run tests post-UI changes (Tasks 14,15,16) to validate no new violations.\n\n**Success Criteria:**\n- 0 critical WCAG 2.1 AA violations across apps.\n- Full keyboard navigation support.\n- Touch targets meet 44px standard.\n- Performance: All interactions <1s response time.",
        "status": "pending",
        "dependencies": [
          "11",
          "12",
          "13",
          "14",
          "15",
          "16"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Playwright configuration and install accessibility dependencies",
            "description": "Install required packages and configure playwright.config.ts with projects for PrepChef, Admin CRM, and Display apps including WCAG 2.1 AA axe-core ruleset.",
            "dependencies": [],
            "details": "Run `npm install --save-dev @playwright/test @axe-core/playwright @axe-core/react`; update playwright.config.ts with specified projects (prepchef-mobile iPhone 14, admin-crm-web 1280x720, display-kiosk 1920x1080) and axe-core configuration { runOnly: { type: 'tag', values: ['wcag2a', 'wcag2aa'] } }. Exclude third-party embeds with 'data-skip-a11y'.[1][4]",
            "status": "pending",
            "testStrategy": "Verify config loads without errors: `npx playwright test --list` shows all projects; manual check config file syntax.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement axe-core WCAG 2.1 AA automated scans for critical paths",
            "description": "Create tests/accessibility/axe-scans.spec.ts performing full-page and component-level axe-core scans on login, dashboard, task lists, task details across all three apps.",
            "dependencies": [
              1
            ],
            "details": "Use AxeBuilder with .withTags(['wcag2a', 'wcag2aa']) on critical paths; expect(results.violations).toEqual([]); include shared UI from @codemachine/ui; generate HTML reports with `npx playwright show-report`.[1][4]",
            "status": "pending",
            "testStrategy": "Run `npx playwright test accessibility/axe-scans.spec.ts` expecting 0 violations on WCAG 2A/2AA rules across all projects.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Develop keyboard navigation test suite",
            "description": "Create tests/accessibility/keyboard.spec.ts to validate Tab, Shift+Tab, Enter, Space, Escape keys on all interactive elements with logical focus order and skip links.",
            "dependencies": [
              1
            ],
            "details": "Test tab through buttons, forms, modals; verify :focus visibility; implement focus management per Task 13 patterns across PrepChef mobile flows, Admin CRM dashboard, Display kiosk screens.[3][4]",
            "status": "pending",
            "testStrategy": "Manual verification of focus indicators during test execution; assert expect(page.locator(':focus')).toBeVisible() after each keypress.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Build screen reader compatibility tests",
            "description": "Create tests/accessibility/screenreader.spec.ts verifying ARIA landmarks, roles, labels using getByRole(), live regions, aria-live status/alert on dynamic content like toasts.",
            "dependencies": [
              1
            ],
            "details": "Test ARIA attributes on toasts (Task 12), landmarks, roles; validate dynamic announcements using Playwright's getByRole() API across all apps.[4]",
            "status": "pending",
            "testStrategy": "Assert getByRole('status'), getByRole('alert') exist and have proper labels; verify live region announcements trigger correctly.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement touch targets and performance metrics tests with CI integration",
            "description": "Create tests/accessibility/performance.spec.ts for 44px touch targets, response times, kiosk readability; integrate suite into CI/CD for PR runs.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Assert button.boundingBox().width >= 44; expect(locator).toBeEnabled({timeout:300}); add high-contrast checks for Display (Task 14); run `npx playwright test --project=accessibility` on every PR.[11]",
            "status": "pending",
            "testStrategy": "Execute full suite `npx playwright test --project=accessibility` expecting pass on all apps; fail on violations, warn on needsReview; verify CI integration triggers on PRs.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "18",
        "title": "Conduct in-kitchen usability testing of PrepChef mobile with real kitchen staff",
        "description": "Run structured usability testing sessions with real kitchen staff using the PrepChef mobile app in an active kitchen environment to validate task flows, touch interactions, and workflow efficiency, while capturing quantitative UX metrics and qualitative feedback.",
        "details": "**Scope and objectives**\n- Evaluate **end-to-end task flows** in the PrepChef mobile app (e.g., viewing task list, starting/pausing/completing tasks, handling errors) with real kitchen staff in their actual kitchen environment.[3][5]\n- Validate **touch interactions**: tap accuracy on primary actions, discoverability of key controls, and responsiveness under time pressure and with gloved/wet hands (where applicable).[3][4]\n- Measure **workflow efficiency** impact on kitchen operations: time-on-task, interruptions, and coordination between staff stations when using the app during real prep/service windows.[1][8]\n- Collect both **quantitative usability metrics** (task success rate, time on task, error rate, user satisfaction) and **qualitative insights** (friction points, mental models, workarounds).[2][3][5]\n\n**Dependencies and preconditions**\n- Assume **Task 11** has delivered the single-tap primary action flow and WCAG-compliant touch targets so that this study evaluates the updated interaction model.\n- Coordinate with product/ops to ensure a **stable test build** of PrepChef mobile (feature-flagged as needed) and access to a realistic backend/test environment mirroring production data volumes.[4][9]\n\n**Study design**\n- Define **research goals & hypotheses**:\n  - Hypothesis examples: \"Single-tap primary actions reduce average task completion time by X%\"; \"WCAG-compliant touch targets reduce tap error rate under kitchen conditions.\"[3]\n  - Align metrics with key KPIs: **task success rate, time on task, error rate, user satisfaction (SEQ or SUS subscales)**.[3][2]\n\n- Identify **core task scenarios** (approx. 6–10 per session):\n  - Scan today’s task list, filter by station or priority, and pick the next task.\n  - Start a prep task, mark ingredients ready, update status to done.\n  - Pause and resume a task while handling an interruption.\n  - Resolve a typical error (e.g., missing ingredient, wrong station) using available flows.\n  - Use any feedback/notification patterns that affect the workflow (e.g., toasts, status confirmations).\n\n- **Participant recruitment**:\n  - Recruit 8–15 **representative kitchen staff** (line cooks, prep cooks, expeditors) from 2–3 different locations/shifts to capture varied workflows.[2][5]\n  - Screen for familiarity with smartphones but mix levels of familiarity with PrepChef to understand both onboarding and expert usage.\n\n- **Environment & equipment**:\n  - Conduct sessions **in the live kitchen environment** during realistic, but controlled, service windows (e.g., slower periods) to capture authentic constraints: noise, motion, lighting, gloves, and surface contamination.[1][5][6]\n  - Use the same hardware form factors deployed in production (device models, screen sizes, cases, mounts).\n  - Prepare video recording (with consent) using overhead or shoulder-mounted cameras focused on hands + screen, plus screen recording if possible.[5]\n\n- **Test protocol** (aligned with mobile usability best practices):[3][5][6]\n  - Start with a short **introduction and consent** (purpose, recording, confidentiality, that the app—not the participant—is being tested).\n  - Use a **think-aloud protocol** where practical, but prioritize safety and realistic behavior: prompt verbalization during lulls rather than while handling hot or hazardous items.[2][6]\n  - Present each scenario as a **realistic kitchen task** rather than instructions about UI elements, e.g., \"You just got a new order for 3 salads; use PrepChef to see what you need to prep first.\"[2][3]\n  - Do not coach on specific UI steps; only clarify goals to reveal discoverability and navigation issues.[5][6]\n  - After each task, capture **Single Ease Question (SEQ)** (1–7 scale: \"Overall, how easy or difficult was this task?\") and any immediate comments.[3]\n  - After the full session, administer a short **post-test questionnaire** (e.g., SUS-like items or a brief custom survey) about overall usability, perceived speed, and fit with existing workflow.[3]\n\n**Metrics and instrumentation**\n- **Core quantitative metrics** per task:[3][2]\n  - **Task success rate** (completed without assistance / with minor assistance / failed).\n  - **Time on task** (start to successful completion or abandonment).\n  - **Error rate** (number of observable mis-taps, backtracks, wrong screens, or misinterpretations of status per task).[3]\n  - **Tap precision** proxies: number of repeated taps on the same control, mis-hits on adjacent elements.\n  - **User satisfaction**: SEQ per task and overall post-test ratings.[3]\n\n- **Data capture methods**:\n  - Use a **structured observation sheet** for moderators to log:\n    - Steps taken, deviations from expected flow.\n    - Errors, hesitations, visible confusion.\n    - Environmental factors (noise spikes, rush periods, gloves, wet hands).\n  - Where feasible, instrument the app (feature flag) to log:\n    - Screen transitions for tested flows.\n    - Timestamps for key actions (task opened, primary action tapped, status updated).\n    - Tap events on primary actions and error dialogs (aggregated, non-PII).[4][9]\n\n**Session operations**\n- **Pilot test** with 1–2 kitchen staff (or internal proxy session in a test kitchen) to validate:\n  - Scenario clarity and duration (~30–45 minutes per participant).[5]\n  - Feasibility of note-taking and recording in a busy kitchen.\n\n- **Run study**:\n  - Schedule sessions to avoid peak rush but still include realistic pressure.\n  - Use **two-person teams** where possible: a moderator (guides session) and a note-taker (logs metrics and observations).[5]\n  - Maintain safety: keep observers clear of line-of-fire areas; stop or pause tasks if participants must focus on safety-critical work.\n\n**Analysis and synthesis**\n- **Quantitative analysis**:[2][3][5]\n  - Compute per-task and per-role aggregates: median time on task, success rate, and error rate.\n  - Compare performance across environmental conditions (e.g., gloves vs bare hands, mounted vs handheld) when data volume allows.\n  - Identify tasks with **low success rate (<80%)**, **high error rate**, or **high SEQ difficulty (>4)** as candidates for design changes.\n\n- **Qualitative analysis**:[5]\n  - Transcribe key moments from recordings where users struggle, hesitate, or express confusion.\n  - Thematically code issues (navigation, wording, visibility, feedback latency, physical ergonomics).\n  - Prioritize issues by severity and frequency (e.g., critical, major, minor) and map to impacted flows/components in PrepChef.\n\n- **Output deliverables**:\n  - A **usability findings report** with:\n    - Summary of participants, context, scenarios.\n    - KPI tables/graphs for task success, time, errors, and satisfaction.\n    - Top issues, each with evidence (screenshots, quotes), severity, and recommended design/interaction changes.\n  - A **prioritized backlog list** (user stories or tickets) for UI/UX and engineering teams tied to specific components (e.g., `TaskListScreen`, `TaskDetailScreen`, `PrimaryActionButton`).\n  - A short **stakeholder readout** (slides or Loom-style walkthrough) highlighting key insights for product, design, and engineering.\n\n**Best practices and ethics**\n- Keep participant interaction **non-disruptive** to kitchen throughput: limit per-session time, coordinate with managers, and pause testing during peak surges.[1][6]\n- Ensure **anonymity** in reports: no individual names, only roles and locations.\n- Confirm that test builds and captured data respect privacy and contain no real guest PII.\n- Plan for **iterative cycles**: after implementing high-priority fixes, run a lightweight follow-up usability check on the same core tasks to confirm improvements.[3][5]",
        "testStrategy": "- **Pre-test setup**\n  - Verify the PrepChef test build includes the latest single-tap primary action flows and that analytics/telemetry for key actions is enabled in a non-production environment.\n  - Dry-run the full protocol internally (using at least one real kitchen workstation) to validate timing, recording setup, and that all observation sheets and surveys are clear and unambiguous.\n\n- **Protocol validation during pilot**\n  - Conduct 1–2 pilot sessions with kitchen staff or realistic proxies.\n  - Confirm that:\n    - Each task scenario can be completed within a reasonable time without moderator over-explaining the interface.\n    - Observation templates capture all needed metrics (task success, time, errors, SEQ) without overwhelming the note-taker.\n    - Recording quality (video/screen) is sufficient to reconstruct user actions.\n  - Adjust scenarios, instructions, and data collection sheets based on pilot findings.\n\n- **Execution quality checks**\n  - For each live session, ensure:\n    - Consent is obtained and documented before any recording.\n    - The moderator follows the script and only provides neutral, non-leading prompts.\n    - The note-taker logs start/end times, outcomes, and observed errors for each task.\n  - After 2–3 sessions, perform a quick interim review of notes to check consistency of severity ratings and metric logging, and recalibrate among researchers if needed.\n\n- **Data integrity verification**\n  - Cross-check logged task times from observation sheets against any available in-app telemetry to validate measurement accuracy.\n  - Spot-check a subset of recorded sessions to confirm that coded errors and success/failure labels match what is visible in the video.\n  - Ensure all collected data is stored securely and de-identified before analysis and sharing.\n\n- **Analysis validation**\n  - Recalculate key KPIs (task success rate, mean/median time on task, error rate, SEQ scores) independently by two team members for at least one representative task set to verify that results match.\n  - Review the prioritized issue list in a joint workshop (UX + engineering + product) to confirm severity and feasibility assessments.\n\n- **Outcome verification**\n  - Derive at least 5–10 concrete, actionable recommendations tied to specific screens/components and supported by both qualitative evidence and quantitative metrics.\n  - After implementing top-priority fixes in subsequent tasks, plan a follow-up mini-test (3–5 participants) and confirm that:\n    - Task success rates improve or remain high.\n    - Time on task and error rates are stable or improved.\n    - SEQ scores move towards easier ratings for previously problematic tasks.\n  - Document learnings and update internal usability testing playbook for future PrepChef and Admin/Display app studies.",
        "status": "pending",
        "dependencies": [
          "11"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Define research goals, hypotheses, core task scenarios, and test protocol",
            "description": "Establish the research goals, hypotheses, participant criteria, core task scenarios (6-10 per session), and detailed test protocol including think-aloud, SEQ, and post-test questionnaire.",
            "dependencies": [],
            "details": "Align metrics with KPIs like task success rate, time on task, error rate, SUS/SEQ. Define scenarios such as scanning task list, starting/pausing tasks, error resolution. Prepare scripts for introduction, consent, and task presentation as realistic kitchen tasks without UI coaching.",
            "status": "pending",
            "testStrategy": "Review protocol against best practices from usability guidelines; conduct internal dry-run review for clarity and completeness.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Recruit participants and prepare test environment and equipment",
            "description": "Recruit 8-15 representative kitchen staff from 2-3 locations/shifts, screen for smartphone familiarity, and set up live kitchen environment with production hardware, mounts, video recording setup.",
            "dependencies": [],
            "details": "Coordinate with product/ops for stable test build (feature-flagged) and backend mirroring production. Schedule sessions during slower periods for safety. Prepare consent forms, observation sheets, and recording equipment (overhead/shoulder cameras, screen recording).",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Conduct pilot test and execute main usability testing sessions",
            "description": "Run pilot test with 1-2 staff to validate protocol (~30-45 min/session), then execute full sessions using two-person teams (moderator/note-taker), capturing metrics and feedback in live kitchen.",
            "dependencies": [
              1,
              2
            ],
            "details": "Use think-aloud where safe, log quantitative metrics (success rate, time, errors, SEQ) and qualitative notes on observation sheets. Employ app instrumentation for taps/transitions. Ensure non-disruptive operations, safety, and pausing during peaks.",
            "status": "pending",
            "testStrategy": "Verify pilot identifies any scenario issues; during main sessions, cross-check logged metrics against video for accuracy and completeness.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Collect and organize quantitative and qualitative data",
            "description": "Gather all session data including observation sheets, video recordings, SEQ/post-test scores, app logs; transcribe key moments and compile into structured format for analysis.",
            "dependencies": [
              3
            ],
            "details": "Categorize data by task, role, conditions (e.g., gloves, pressure). Aggregate raw metrics: task success, time on task, error rates, satisfaction. Note environmental factors and workarounds.",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Analyze findings and produce deliverables",
            "description": "Perform quantitative analysis (aggregates, comparisons), qualitative thematic coding, prioritize issues; create usability report, prioritized backlog, and stakeholder readout.",
            "dependencies": [
              4
            ],
            "details": "Compute medians for KPIs, identify low-success tasks (<80%), code issues by severity/frequency. Output: report with KPIs/tables/quotes, backlog tickets for components like TaskListScreen, slides/Loom for stakeholders.",
            "status": "pending",
            "testStrategy": "Validate analysis by cross-referencing quantitative outliers with qualitative evidence; review backlog items for traceability to findings.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "19",
        "title": "Define Chrome DevTools UX Validation Protocol and Checklists",
        "description": "Develop a standardized Chrome DevTools–based UX validation protocol with detailed checklists for touch targets, performance profiling, accessibility audits, and visual hierarchy, including procedures for testing on real devices and kiosk displays.",
        "details": "## Scope and Goals\n- Create a **repeatable UX validation protocol** using Chrome DevTools and related tooling for:\n  - **Touch target validation** (hit areas, interaction latency) on mobile and kiosk views.\n  - **Performance profiling** focused on UX-centric metrics (LCP, FID/INP, CLS, responsiveness) using the Performance panel and Lighthouse.[7][9]\n  - **Accessibility audits** using DevTools Accessibility pane and Lighthouse, aligned with WCAG 2.1 AA and existing automated suites.[7][9]\n  - **Visual hierarchy assessment** via layout overlays, contrast tools, and device emulation.[7]\n- Document **standard procedures for real devices and kiosk displays**, including configuration of DevTools Remote Debugging and consistent test environments.[7][9]\n\n## Implementation Details\n\n### 1. Protocol Structure & Documentation Format\n- Create a dedicated UX testing guide in the docs repo (e.g. `docs/qa/ux-devtools-protocol.md`) with:\n  - Overview of objectives and when to run each type of UX validation (e.g., before release, after major UI refactors, after token changes).\n  - A consistent structure for each section: **Purpose → Tools → Pre-requisites → Step-by-step procedure → Pass/Fail criteria → Reporting template**.\n- Provide printable / copy-pastable **checklist tables** for each category (touch targets, performance, accessibility, visual hierarchy).\n\n### 2. Touch Target Validation Checklist (Mobile & Kiosk)\n- Base checklist on common UX guidelines (44×44 px or equivalent logical size, spacing, and error prevention) and integrate with DevTools capabilities.[7][9]\n- Define **pre-requisites**:\n  - Build to test environment with latest design tokens and component updates (depends on @codemachine/ui token standardization work from Task 16).\n  - Known viewport presets (e.g., 360×640 for phone, actual kiosk resolution from Task 14 work).\n- Define **DevTools-based procedure**:\n  - Use **Device Mode** in Chrome DevTools to emulate target devices, DPR, and throttling; save presets for PrepChef mobile and Display kiosk.[7]\n  - Use **Inspect Element** to verify rendered tap target sizes and spacing; document recommended minimum CSS sizes and how to measure with the DevTools box model and rulers.[7]\n  - Use the **Performance panel** to record tap interactions and check input delay (look for long tasks >50 ms after input events).[9]\n  - For kiosk: combine with typography and density constraints defined in Task 14 (e.g., ensure large tap regions for large, distant buttons).\n- Create a **Touch Target Checklist**, e.g.:\n  - All primary actions meet minimum size threshold (specify px and logical size). \n  - Minimum spacing between adjacent tap targets.\n  - No critical control is within N px of screen edges used for OS gestures.\n  - Input delay on primary flows < specified threshold (e.g., <100 ms on average traces).\n\n### 3. Performance Profiling Protocol\n- Base protocol on **DevTools Performance panel** and **Lighthouse** best practices.[7][9]\n- **Pre-requisites**:\n  - Clear cache or use an Incognito window.\n  - Configure consistent network/CPU throttling profiles (e.g., Fast 3G / 4× CPU slowdown) and save them as shared presets.[9]\n- **Step-by-step DevTools Performance workflow**:[9]\n  - Open Performance panel, enable screenshots and Web Vitals if available.\n  - Start a recording, perform a defined UX flow (e.g., open dashboard, scroll list, trigger bulk action, kiosk update), stop recording.\n  - Identify **LCP**, **CLS**, long tasks, and main-thread blocking time in the summary pane.[9]\n  - Annotate trace screenshots with timestamps for critical UX moments (screen appears, controls become interactive).\n- **Lighthouse procedure**:\n  - Run Lighthouse from DevTools for both mobile and desktop modes, capture Performance and Accessibility scores.[7]\n  - Export Lighthouse JSON/HTML reports and link them in the test report template.\n- Create a **Performance Checklist**, including:\n  - LCP < defined threshold on key screens.\n  - Minimal layout shift on load and during updates.\n  - No long tasks above agreed budget on core flows.\n  - Stable FPS for scrolling and kiosk auto-updates (no visible jank).\n\n### 4. Accessibility Audit Protocol (DevTools-focused)\n- Align this manual DevTools protocol with the **automated axe/Playwright suite from Task 17** and clarify **when to use which**.\n- **DevTools Accessibility pane workflow**:[7]\n  - Use the **Elements → Accessibility** tree to inspect role, name, and state of key controls.\n  - Verify focus order by using keyboard navigation and observing the active element in DevTools.\n- **Lighthouse Accessibility**:\n  - Run Lighthouse Accessibility audits for target pages and capture issues list.[7]\n  - Map Lighthouse findings to WCAG 2.1 AA criteria and to automated Playwright/axe tests from Task 17.\n- Create an **Accessibility Checklist**, e.g.:\n  - All interactive elements have correct roles, labels, and focus indicators.\n  - No contrast violations according to Lighthouse; for kiosk, cross-check with high-contrast mode from Task 14.\n  - Keyboard-only users can complete key flows (confirmed via DevTools inspection and manual keyboard walkthrough).\n\n### 5. Visual Hierarchy Assessment Protocol\n- Describe how to use DevTools to assess **visual hierarchy**:\n  - Device Mode for mobile vs kiosk layouts and zoomed-out views for distance perception.[7]\n  - Element highlighting and layout tools (such as box model overlays and CSS Grid/Flex overlays) to check spacing and alignment.[7]\n  - Emulation of different color schemes/high-contrast modes and simulated color vision deficiencies (where supported) to assess priority and contrast.[7]\n- Define **heuristics** for hierarchy:\n  - Clear visual priority for primary KPIs and actions (ties to Task 15 dashboard and Task 14 kiosk redesign).\n  - Consistent use of type scale, color, and spacing from standardized design tokens (Task 16).\n- Provide a **Visual Hierarchy Checklist**, including:\n  - Primary KPIs/buttons appear above the fold and are visually dominant.\n  - Secondary information is visually subordinate but still legible.\n  - No conflicting cues (e.g., secondary actions styled more prominently than primary).\n\n### 6. Real Device and Kiosk Testing Procedures\n- Document how to connect **real Android/iOS devices and kiosk hardware** to DevTools for remote debugging and performance profiling:[7]\n  - Android: enable Developer Options, USB debugging, connect via `chrome://inspect`.\n  - Kiosk: connect to the kiosk’s browser session via remote debugging port.\n- Define **environment setup**:\n  - Required Chrome version range and flags.\n  - Standard display settings for kiosk runs (resolution, scaling, brightness, distance from viewer) referencing Task 14 test setup.\n- Provide step-by-step **real-device protocol**:\n  - Connect device, open target app or PWA, attach DevTools.\n  - Run the same touch, performance, accessibility and hierarchy checklists as in emulation, noting any discrepancies.\n  - Capture screenshots and video of real usage where relevant.\n\n### 7. Integration with Existing Testing & Reporting\n- Define how this UX protocol complements:\n  - **Task 17** automated Playwright/axe accessibility and performance tests.\n  - **Task 18** in-kitchen usability sessions (DevTools traces can be recorded during real sessions for deeper analysis).\n- Create a **standard report template** (e.g., `docs/qa/templates/ux-devtools-report.md`) with sections:\n  - Context (build version, date, tester, device information).\n  - Checklists with pass/fail and notes.\n  - Links to DevTools performance recordings (saved JSON traces), Lighthouse reports, screenshots.\n  - Prioritized issues with severity and suggested owners (@ui-ux, @business-logic, etc.).\n\n### 8. Knowledge Sharing\n- Add short **how-to snippets** and annotated screenshots to help new team members follow the protocol.\n- Schedule an internal walkthrough to present the protocol to QA, UX, and engineering, and capture adjustments based on feedback.\n\n## Current Best Practices & Technologies Reflected\n- Use of **Chrome DevTools Performance panel, Lighthouse, Device Mode, Accessibility panel** as primary tools for diagnostic UX testing.[7][9]\n- Emphasis on **LCP, CLS, long tasks, and interactivity** as key performance metrics when evaluating UX responsiveness.[9]\n- Integration with **Chrome DevTools Protocol–based automation** (Puppeteer, etc.) as future extensions, but keeping this task primarily documentation/protocol-focused.[1][4][6]\n",
        "testStrategy": "## Overall Validation\n- Verify that the **UX DevTools protocol document** and **checklists** exist, are complete, and accessible in the agreed documentation location (e.g., `docs/qa/ux-devtools-protocol.md` plus templates).\n- Confirm that each checklist (touch targets, performance, accessibility, visual hierarchy) includes: tools, pre-requisites, ordered steps, explicit pass/fail thresholds, and reporting fields.\n\n## Protocol Dry Runs\n\n### 1. Touch Target Validation\n- Using a recent build of PrepChef mobile and the Display kiosk:\n  - In Chrome DevTools, enable Device Mode with the documented viewport presets and follow the touch target checklist step-by-step.\n  - Confirm a tester can:\n    - Measure tap target sizes and spacing using Inspect and box model overlays.\n    - Record a Performance trace around a tap and locate the associated input events and long tasks.\n  - Ensure the checklist yields actionable results (at least one example issue can be recorded if present) and that fields are clear.\n\n### 2. Performance Profiling\n- For at least one key flow in Admin CRM dashboard (Task 15) and one in Display kiosk:\n  - Apply the documented network/CPU throttling settings.\n  - Record a Performance trace following the protocol.\n  - Verify the tester can reliably identify LCP, CLS and long tasks and evaluate them against the documented thresholds.\n  - Run Lighthouse from DevTools in both mobile and desktop modes, confirm the protocol’s instructions match the actual UI.\n\n### 3. Accessibility Audits\n- On a target screen in Admin CRM and Display kiosk:\n  - Follow the Accessibility protocol to inspect roles, names and focus order via DevTools.\n  - Run Lighthouse Accessibility and confirm the steps and screenshots in the doc align with the experienced workflow.\n  - Cross-check a subset of issues discovered here against results from the Playwright/axe suite (Task 17) to ensure conceptual alignment.\n\n### 4. Visual Hierarchy Assessment\n- On the Admin CRM dashboard and the main kiosk screen:\n  - Follow the Visual Hierarchy checklist to evaluate priority of KPIs/actions and use DevTools overlays as described.\n  - Confirm that two independent reviewers using the same checklist arrive at similar qualitative conclusions (sanity-check clarity of criteria).\n\n### 5. Real Device and Kiosk Procedures\n- Connect an Android test device via USB and:\n  - Attach Chrome DevTools using `chrome://inspect` following the documented steps.\n  - Perform at least one short performance trace and one accessibility inspection, ensuring the instructions are accurate and complete.\n- On a kiosk setup (or a representative large external display):\n  - Attach DevTools via remote debugging.\n  - Follow the kiosk-specific parts of the protocol, including distance and readability notes from Task 14.\n\n### 6. Documentation Quality and Maintainability\n- Have at least one QA engineer and one UX designer follow the protocol **without prior explanation** and:\n  - Complete all four checklists on a sample screen.\n  - Provide feedback on missing steps, ambiguities, or incorrect references; update the document accordingly.\n- Confirm all referenced artifacts (Lighthouse exports, performance trace examples, report template) are linked or clearly located and version-controlled.\n",
        "status": "pending",
        "dependencies": [
          "14",
          "16",
          "17",
          "18"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Define overall UX DevTools protocol structure and documentation artifacts",
            "description": "Design the high-level structure, sections, and file locations for the Chrome DevTools UX validation protocol and associated templates.",
            "dependencies": [],
            "details": "• Create the main protocol document skeleton (e.g., docs/qa/ux-devtools-protocol.md) including sections for touch targets, performance profiling, accessibility audits, visual hierarchy, and real-device/kiosk procedures.\n• Standardize section format as Purpose → Tools → Pre-requisites → Step-by-step procedure → Pass/Fail criteria → Reporting template.\n• Specify naming/location for supporting artifacts (e.g., docs/qa/templates/ux-devtools-report.md, per-checklist subsections or tables within the main doc).\n• Align terminology and scope with Tasks 14, 16, 17, and 18 so cross-references can be added cleanly in later subtasks.\n• Get quick sign-off from UX/QA on the outline before populating detailed content.",
            "status": "pending",
            "testStrategy": "Open the new documentation files, verify required sections and headings exist and follow the agreed structure; confirm links between main protocol and template locations work.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Author touch target validation checklist and procedures (mobile & kiosk)",
            "description": "Create a DevTools-based touch target validation checklist and step-by-step workflow for mobile and kiosk experiences.",
            "dependencies": [
              1
            ],
            "details": "• Document pre-requisites: test build availability, design tokens and components from Task 16, and viewport presets (phone and kiosk resolutions referencing Task 14 outputs).\n• Describe how to configure and save Device Mode presets for key devices, including DPR, throttling, and kiosk resolutions.\n• Define a measurement procedure using Inspect Element, box model, rulers, and overlays to verify tap target size and spacing; include recommended minimum CSS/px and logical size values.\n• Specify how to capture and review interaction latency using the Performance panel (recording taps, checking long tasks >50 ms after input events).\n• Produce a printable/copy-paste checklist table covering size thresholds, spacing, edge proximity, and latency budgets for core flows on both mobile and kiosk.\n• Add guidance for interpreting failures and linking issues back to token or component changes from Task 16.",
            "status": "pending",
            "testStrategy": "Run the checklist on at least one mobile view and one kiosk layout, verify each step is clear and feasible, and confirm that measurements and latency checks can be reproduced by another tester following only the written protocol.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Define performance profiling and Lighthouse-based UX checks",
            "description": "Specify a repeatable DevTools Performance panel and Lighthouse workflow with a UX-focused performance checklist.",
            "dependencies": [
              1
            ],
            "details": "• Document environment pre-requisites: using Incognito or cleared cache, standardized network/CPU throttling profiles, and how to save and share these as presets.\n• Write a step-by-step procedure for capturing Performance traces for representative UX flows (navigation, scrolling, kiosk updates), including enabling screenshots and Web Vitals.\n• Describe how to identify and record LCP, CLS, long tasks, and main-thread blocking time from traces, and how to annotate critical UX timestamps.\n• Define the Lighthouse run procedure in DevTools for mobile and desktop modes, including which categories to select and how to export/store reports.\n• Create a performance checklist table with concrete thresholds for LCP, acceptable layout shift, long-task budgets, and scroll/FPS expectations for both standard and kiosk scenarios.\n• Note how this protocol complements existing automated performance checks (e.g., from Task 17) without duplicating them.",
            "status": "pending",
            "testStrategy": "Execute the documented workflow on at least one key user flow, verify that another tester can obtain similar metrics and Lighthouse scores, and confirm that all checklist items can be filled using only data from the described tools.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create accessibility and visual hierarchy DevTools audit checklists",
            "description": "Develop DevTools-focused procedures and checklists for accessibility audits and visual hierarchy assessment, integrated with existing automation and design tokens.",
            "dependencies": [
              1
            ],
            "details": "• For accessibility, document a workflow using the DevTools Accessibility pane and keyboard navigation to inspect roles, names, states, focus order, and focus indicators on key flows.\n• Specify how and when to run Lighthouse Accessibility audits, and how to map their findings to WCAG 2.1 AA and to the automated Playwright/axe suite from Task 17.\n• Build an accessibility checklist table covering roles/labels, focus management, keyboard-only completion of flows, and contrast requirements (with kiosk-specific notes referencing Task 14 high-contrast setups).\n• For visual hierarchy, outline how to use Device Mode, element highlighting, layout overlays, and color/emulation tools to evaluate spacing, alignment, prominence of primary actions/KPIs, and consistency with design tokens from Task 16.\n• Create a visual hierarchy checklist table capturing hierarchy heuristics (primary vs secondary information, above-the-fold presence, avoidance of misleading visual cues).\n• Include brief notes on interpreting common issues and how to feed them back to UX and design-token owners.",
            "status": "pending",
            "testStrategy": "Apply the accessibility and visual hierarchy checklists to at least one dashboard and one kiosk screen, verify all items can be evaluated using the documented DevTools steps, and confirm alignment with existing automated accessibility reports.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Document real-device/kiosk procedures and integrate reporting template",
            "description": "Define remote debugging procedures for real devices and kiosks and finalize the unified UX DevTools reporting workflow.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "• Document step-by-step instructions to connect Android devices (via Developer Options and chrome://inspect) and kiosk hardware (via remote debugging ports) to DevTools.\n• Specify standard environment settings for kiosks (Chrome versions, resolution, scaling, brightness, and viewing distance) referencing Task 14’s test setup.\n• Describe how to re-run the touch target, performance, accessibility, and visual hierarchy checklists on physical devices, including how to note differences from emulation.\n• Define expectations for capturing and storing screenshots, videos, Performance traces, and Lighthouse reports during real-device sessions.\n• Create or complete the standard report template (e.g., docs/qa/templates/ux-devtools-report.md) with sections for context, checklist results, attached artifacts, and prioritized issues/owners.\n• Add guidance on how this protocol feeds into Task 18 in-kitchen usability sessions and how QA/UX should share findings with engineering.",
            "status": "pending",
            "testStrategy": "Dry-run the full protocol on at least one real mobile device and one kiosk setup, fill out the report template end-to-end, and verify that another team member can reproduce the setup and reporting using only the documented steps.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "20",
        "title": "Implement robust toast notification system in PrepChef with undo actions, Supabase integration, and feature flag gating",
        "description": "Add a comprehensive ToastContext, accessible Toast component, and undo-capable notifications in PrepChef app, wired to TaskCard with Supabase backend calls gated by Flagsmith feature flag.",
        "details": "**Owner:** @ui-ux\n\n**Implementation Steps:**\n\n1. **Create ToastContext** (`apps/prepchef/contexts/ToastContext.tsx`):\n   - Implement React Context with `useState` for toast queue (array of `{id, message, type, actionLabel, onAction, durationMs, dismiss}`)\n   - `showToast({id?: string, message: string, type: 'success'|'error'|'info'|'warning', actionLabel?: string, onAction?: () => Promise<void>, durationMs?: number})` API\n   - Support max 3 concurrent toasts (queue older ones or dismiss)\n   - Auto-dismiss timers via `useEffect` with `setTimeout` (SSR-safe: check `typeof window !== 'undefined`)\n   - Cancel timers on undo/action/dismiss\n   - Export `ToastProvider` and `useToast` hook\n\n2. **Extend shared useToast hook** (`libs/shared/src/hooks/useToast.tsx`):\n   - Add optional `actionLabel` and `onAction` params to existing `showToast`\n   - Maintain backward compatibility: existing callers without these params work unchanged\n   - Delegate to app-specific ToastContext if available, fallback to existing implementation\n   ```typescript\n   // Backward compatible extension\n   export const useToast = () => {\n     const context = useContext(ToastContext);\n     return {\n       showToast: (opts: ToastOptions & {actionLabel?: string, onAction?: () => Promise<void>}) => {\n         if (context) return context.showToast(opts);\n         // existing implementation\n       }\n     };\n   };\n   ```\n\n3. **Build accessible Toast component** (`apps/prepchef/components/Toast.tsx`):\n   - Use `@codemachine/ui` tokens for styling (colors, spacing, typography)\n   - ARIA: `role='status'` (success/info) or `role='alert'` (error), `aria-live='polite'` (success/info) or `'assertive'` (error)\n   - Keyboard: `tabIndex={0}` on action button, `onKeyDown` for Enter/Space activation\n   - Focus management: do not steal focus from primary flows, optional `autoFocus` only on first error toast\n   - Animate with CSS transitions (framer-motion if in `@codemachine/ui`)\n   - Limit stack height, auto-dismiss with pause-on-hover\n\n4. **Wrap app root** (`apps/prepchef/app/layout.tsx`):\n   - Add `<ToastProvider>` at root level (after other providers)\n   ```tsx\n   <body>\n     <Providers>{children}</Providers>\n     <ToastContainer /> {/* Fixed position overlay */}\n   </body>\n   ```\n\n5. **Wire TaskCard** (`apps/prepchef/components/TaskCard.tsx`):\n   - On successful `updateTaskStatus(taskId, newStatus)` via @business-logic API:\n     ```tsx\n     const { prevStatus } = trackStatusChange(taskId, newStatus);\n     const toast = useToast();\n     toast.showToast({\n       message: `Task marked as ${newStatus}`,\n       type: 'success',\n       actionLabel: flags.prepchef_toast_undo ? 'Undo' : undefined,\n       onAction: flags.prepchef_toast_undo ? () => updateTaskStatus(taskId, prevStatus) : undefined,\n     });\n     ```\n   - Use existing Flagsmith wrapper (search codebase for `flags.*` or `useFlags`)\n\n6. **Feature Flag Integration**:\n   - Use existing Flagsmith client: `const flags = useFlags();`\n   - Gate `actionLabel`, `onAction`, and undo UI/behavior behind `flags.prepchef_toast_undo`\n   - Base toasts (message + type + dismiss) always available\n\n7. **Supabase Integration**:\n   - Undo calls existing `updateTaskStatus(taskId, prevStatus)` RPC/method\n   - Coordinate with @business-logic if API questions (create follow-up tasks if needed)\n   - Do NOT modify business rules or Supabase schema\n\n8. **Performance & SSR Safety**:\n   - Lightweight: CSS-only animations where possible\n   - Throttle toast updates with `useDeferredValue` or `React.memo`\n   - No `window` at module top-level, use `useEffect`\n\n9. **Storybook & Documentation**:\n   - Add Toast stories showing all types, undo flow, a11y states\n   - PR description: Chrome DevTools screenshots (Performance, Accessibility pane), a11y snapshots\n\n**Constraints:**\n- Coordinate shared token/accessibility patterns with Task 14 (@ui-ux)\n- If Flagsmith absent in PrepChef, create follow-up for @project-wiring\n- Migration note for Admin-CRM if `useToast` changes affect it\n\n**Progress Tracking:** Update PR description with changed files, Storybook links, DevTools screenshots, test results.",
        "testStrategy": "**Unit Tests:**\n- `ToastContext.test.tsx`: verify `showToast` adds to queue, auto-dismiss fires, timers cancel on action/dismiss, max 3 toasts enforced[1][2]\n- `useToast.test.tsx`: backward compatibility (old API works), new undo params forwarded correctly\n- `Toast.test.tsx`: ARIA attributes match type (`role='alert'`, `aria-live='assertive'` for errors), keyboard activation (Enter/Space on action), screen reader announcements via `@testing-library/jest-dom`\n\n**Integration Tests:**\n- `TaskCard.integration.test.tsx`: full flow mock Supabase → `updateTaskStatus` → `showToast` → undo → status reverted\n  ```tsx\n  // Mock Flagsmith on, verify undo button appears and calls API with prevStatus\n  render(<TaskCard task={{status: 'pending'}} />);\n  fireEvent.click(primaryAction);\n  expect(screen.getByRole('button', {name: 'Undo'})).toBeInTheDocument();\n  fireEvent.click(screen.getByRole('button', {name: 'Undo'}));\n  expect(mockUpdateTaskStatus).toHaveBeenCalledWith(taskId, 'pending');\n  ```\n- Flag variations: undo hidden when `prepchef_toast_undo=false`\n\n**Manual/DevTools Verification:**\n- Chrome DevTools → Accessibility pane: 100% compliance for toast landmarks\n- Performance panel: verify <16ms layout shift on toast appear/dismiss\n- Lighthouse Accessibility: 100% score on toast-only page\n- Screen reader: NVDA/VoiceOver announces toasts correctly\n- Keyboard-only: Tab to action → Enter activates undo\n\n**E2E (leverage Task 17 Playwright suite):** `npx playwright test --project=prepchef accessibility/toasts.spec.ts`\n\n**Success Criteria:** All automated tests pass, DevTools screenshots in PR, Storybook stories complete, no accessibility violations.",
        "status": "pending",
        "dependencies": [
          "11",
          "13",
          "14"
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": "21",
        "title": "Complete PrepChef single-tap task flow implementation and validation",
        "description": "Implement the remaining seven work items for the PrepChef single-tap flow, including toast accessibility, undo wiring, TaskCard optimistic UI and layout updates, Storybook and automated tests, Playwright E2E coverage, and Chrome DevTools validation to meet latency and WCAG requirements.",
        "details": "## Scope\nImplement and validate the remaining single-tap flow work from the Task #11 analysis, building on the toast system (Task 20), shared design tokens (Task 16), and accessibility/E2E infrastructure (Tasks 17 and 19). Coordinate UI/UX, business logic, and QA to deliver a production-ready single-tap and undo experience that meets ~100ms perceived latency and WCAG 2.1 AA.\n\n### 1. Toast behavior & accessibility updates\n- Update the ToastContext and Toast component (from Task 20) so the **default `durationMs` is 5000ms** for non-error toasts; keep flexibility to override per-call.\n- Ensure toast markup follows ARIA best practices for status messages:\n  - Use `role=\"status\"` or `role=\"alert\"` depending on toast type (e.g., errors as `alert`, others as `status`).\n  - Add `aria-live=\"polite\"` for non-critical notifications and `aria-live=\"assertive\"` for errors.\n  - Ensure toasts are not focus-stealing by default; rely on live regions for screen readers.\n- Make sure multiple toasts remain individually identifiable for assistive tech via unique IDs and `aria-atomic` where appropriate.\n\n### 2. Wire undo integration for claim/complete RPCs\n- For RPCs that support undo (e.g., claim/complete operations), plumb the `undo_token` from Supabase/Backend responses into the toast system created in Task 20.\n- Extend `showToast` usage in the TaskCard flow to:\n  - Show a success toast with an **Undo** action when operations succeed and include `undo_token`.\n  - Pass an `onAction` handler that calls the undo RPC using the token and rolls UI state back if successful.\n  - Ensure undo callbacks are idempotent and handle race conditions (e.g., operation already undone or superseded).\n- Enforce a clear **undo window** (e.g., until toast auto-dismiss) and document the UX so product and QA have a reference.\n\n### 3. TaskCard optimistic UI & accessibility polish\n- Refactor TaskCard to use **local optimistic state** for claim/complete so the primary action responds within ~100ms:\n  - Immediately update UI state (e.g., status, button label, disabled states) on tap before RPC resolution.\n  - Revert state on error and surface an error toast.\n- Implement accessible focus management:\n  - After primary action, keep focus on a stable control; avoid focus loss when list reorders.\n  - Ensure keyboard focus order remains logical when task status changes.\n  - Use `aria-pressed`, `aria-busy`, or `aria-disabled` where appropriate to reflect state.\n- Add descriptive ARIA labels for primary actions (e.g., \"Claim task: {taskName}\", \"Complete task: {taskName}\") and ensure labels update when state changes.\n- Confirm tap targets meet mobile guidelines (~44x44px) and are visually distinct.\n\n### 4. Visual prominence & mobile-first layout\n- Redesign TaskCard layout for **single dominant action** on mobile:\n  - Make the primary action button visually most prominent with clear hierarchy.\n  - De-emphasize secondary actions using typography, color, and spacing.\n- Apply standardized design tokens from `@codemachine/ui` (Task 16) for spacing, color, typography, and radius so styling is consistent.\n- Optimize layout for narrow viewports first:\n  - Stack elements vertically where necessary.\n  - Ensure content truncation and wrapping are graceful and do not break tap targets.\n- Validate that visual states (hover, focus-visible, pressed, disabled) are distinct and meet contrast requirements.\n\n### 5. Storybook stories & unit tests\n- Add Storybook stories for:\n  - TaskCard default, claimed, and completed states.\n  - Single-tap claim/complete with optimistic UI.\n  - Toasts with and without Undo actions, including error variants.\n- Use Storybook controls to simulate latency and error states for design/UX review.\n- Implement unit tests (e.g., React Testing Library + Jest):\n  - Toast: duration default of 5000ms, ARIA attributes, and Undo callback behavior.\n  - TaskCard: optimistic state transitions, ARIA label updates, and focus behavior when status changes.\n  - Undo integration: verifies `undo_token` is wired through and correct RPCs are invoked.\n\n### 6. Playwright E2E tests for single-tap, undo, and accessibility\n- Extend the Playwright WCAG suite from Task 17 with PrepChef-specific tests:\n  - Single-tap primary action flow (claim/complete) verifying end-to-end behavior and that perceived response is within acceptable latency (e.g., asserts UI state change occurs quickly, using timers/timeouts).\n  - Undo scenarios: perform primary action, click Undo in toast, validate backend state and UI both roll back.\n  - Basic accessibility checks: keyboard navigation to TaskCard actions, presence of key ARIA attributes, and no blocking axe-core violations related to the new UI.\n- Parameterize tests to run on mobile viewports (e.g., iPhone-sized) and over network throttling profiles resembling real kitchen Wi-Fi.\n\n### 7. Chrome DevTools validation\n- Use the DevTools protocol/checklists from Task 19 to validate:\n  - **Mobile-first layout**: correct responsive breakpoints, no horizontal scrolling, consistent spacing and visual hierarchy.\n  - **Accessibility**: run Lighthouse/Accessibility panel to ensure no new WCAG 2.1 AA violations from TaskCard/Toast changes.\n  - **Performance/latency**: profile tapping the single-tap action to ensure main-thread work for the optimistic update is well under 100ms on representative hardware.\n- Document findings and any deviations, and iterate until checklists pass.\n\n### Collaboration & handoffs\n- Coordinate with:\n  - UI/UX for final visual and interaction design approvals.\n  - Backend/business logic owners to confirm `undo_token` contract and edge cases.\n  - QA/automation engineers to align E2E scenarios with regression suites.\n- Keep changes modular and well-documented for future maintenance (component-level docs, inline comments where logic is non-obvious).",
        "testStrategy": "1. Unit & component testing\n- Run Jest/React Testing Library suites for ToastContext, Toast component, TaskCard, and any helper hooks.\n- Verify: default toast duration is 5000ms; ARIA attributes (`role`, `aria-live`, `aria-atomic`) are present and correct by toast type; calling the Undo action triggers the provided `onAction` and cancels auto-dismiss if required.\n- Assert TaskCard optimistic UI: immediate visual state changes on primary action tap; state rollback on simulated RPC error; ARIA labels and pressed/busy states update correctly.\n- Confirm focus management logic with keyboard-only tests (tab/shift+tab) in component harnesses.\n\n2. Storybook review\n- Manually review new stories with design/UX:\n  - Validate visual hierarchy of the single dominant action and mobile spacing.\n  - Confirm error and undo variants meet visual and copy guidelines.\n- Use Storybook accessibility add-ons to spot obvious ARIA or contrast issues.\n\n3. Playwright E2E tests\n- Extend and run Playwright tests (leveraging Task 17 setup):\n  - Single-tap primary action on mobile viewport: assert UI state changes within a tight timeout and that backend state matches after RPC completion.\n  - Undo path: perform primary action, click Undo in toast, verify task status is restored both in UI and via API or database fixtures.\n  - Check basic keyboard accessibility: TaskCard actions reachable via Tab, Enter/Space activate primary action, no focus traps.\n  - Execute axe-core accessibility scan on the main PrepChef task view and ensure 0 new violations attributable to these changes.\n\n4. Chrome DevTools protocol validation\n- Follow the UX validation protocol and checklists from Task 19:\n  - Run Performance panel traces for single-tap interactions on a mobile profile and confirm main-thread work for UI updates is comfortably below 100ms.\n  - Use the Lighthouse Accessibility and Best Practices audits; ensure scores meet agreed thresholds and any issues are triaged or fixed.\n  - Verify touch target sizes and layout in Device Mode for multiple viewport widths; confirm no horizontal scrolling and tap targets remain reliable.\n\n5. Cross-browser and device sanity checks\n- Smoke-test the updated flows on at least one modern Chromium browser and one WebKit-based browser on real mobile or emulator.\n- Confirm that undo toasts and optimistic updates behave consistently and that no race conditions or visual glitches appear under slow network conditions.\n\n6. Acceptance criteria sign-off\n- Obtain sign-off from product/UX on:\n  - Single-tap behavior and visual prominence of the primary action.\n  - Undo flows and copy.\n- Obtain sign-off from QA on:\n  - Passing automated tests (unit + Playwright + accessibility).\n  - Completed DevTools checklists with no blocking issues.\n- Mark the task complete only when all seven work items and validations are demonstrably satisfied and documented.",
        "status": "pending",
        "dependencies": [
          "16",
          "17",
          "19",
          "20"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": "22",
        "title": "Fix tsconfig and Edit Tool Mismatch Blocking UI/UX Agent Edits",
        "description": "Diagnose and resolve tsconfig.json configuration issues and edit tool 'oldString not found' errors that prevent the UI/UX agent from applying changes to Toast.tsx and useToast.tsx in libs/ui and libs/shared, unblocking Task #11 implementation.",
        "details": "Investigate and fix root causes of edit failures reported in session ses_4cf3c0376ffemL8r60XFp5887C, including tsconfig parsing errors and string matching failures during automated edits to Toast components from Task 20[1][2][3].\n\n**Diagnostic Steps:**\n1. Reproduce the failure: Run the UI/UX agent edit session targeting `libs/ui/src/Toast.tsx` and `libs/shared/src/useToast.tsx`, capture exact error logs for 'oldString not found' and 'project tsconfig error'[1][3].\n2. Validate tsconfig.json: Run `tsc --noEmit` across all projects (apps/prepchef, libs/ui, libs/shared) to identify parse errors, invalid paths, or mismatched `include`/`exclude` patterns[2][3]. Check for JSON syntax issues like trailing commas[3].\n3. Audit workspace tsconfig: Verify root `tsconfig.json` and workspace `tsconfig.base.json` correctly reference libs/ui and libs/shared via `paths`, `references`, and composite projects[1][2].\n4. Check editor/tool sync: Confirm VS Code/TypeScript version matches project (`npx tsc --version`), restart TS server (Cmd/Ctrl+Shift+P > 'TypeScript: Restart TS Server')[2][4].\n5. Analyze 'oldString not found': Compare agent-expected code strings against actual file contents, checking for whitespace, line endings, or git autocrlf differences[1].\n\n**Fix Implementation:**\n1. **tsconfig fixes**:\n   - Ensure `libs/ui/tsconfig.json` and `libs/shared/tsconfig.json` have valid `extends: '../../tsconfig.base.json'`, correct `include: ['src/**/*']`, and `exclude: ['node_modules', 'dist']`[1][2].\n   - Add `\"createDefaultProgram\": true` temporarily to `.eslintrc.js` parserOptions if editing tsconfig during linting[1].\n   - Update root tsconfig paths: \n     ```json\n     \"paths\": {\n       \"@ui/*\": [\"libs/ui/src/*\"],\n       \"@shared/*\": [\"libs/shared/src/*\"]\n     }\n     ```\n2. **Edit tool reliability**:\n   - Implement file normalization: Add pre-edit step to normalize line endings (LF) and trim whitespace in target files.\n   - Use fuzzy string matching or AST-based edits instead of exact 'oldString' replacement for robustness.\n   - Create `scripts/validate-edit-tool.js` to dry-run edits against current codebase:\n     ```javascript\n     const fs = require('fs');\n     const diff = require('diff');\n     \n     function validateEdit(targetFile, oldStr, newStr) {\n       const content = fs.readFileSync(targetFile, 'utf8');\n       if (!content.includes(oldStr)) {\n         console.error(`'${oldStr}' not found in ${targetFile}`);\n         const matches = content.split('\\n').filter(line => line.includes(oldStr.slice(0, 20)));\n         console.log('Similar lines:', matches);\n         process.exit(1);\n       }\n     }\n     ```\n3. **Workspace hygiene**:\n   - Run `npm run build` and `npm run lint -- --fix` across all packages.\n   - Delete `node_modules/.cache`, `.tsbuildinfo`, restart dev servers.\n4. **Prevent recurrence**:\n   - Add CI check: `tsc --noEmit && npm run lint` in pre-commit hook.\n   - Document tsconfig editing protocol in `docs/development/tsconfig-editing.md`.\n\n**Owner:** @tools-devops\n**Estimated Effort:** 1-2 days",
        "testStrategy": "**Edit Tool Validation:**\n- Re-run UI/UX agent session ses_4cf3c0376ffemL8r60XFp5887C targeting Toast.tsx/useToast.tsx edits: verify 100% success rate, no 'oldString not found' or tsconfig errors.\n- Execute 5+ test edits across libs/ui and libs/shared: confirm changes apply cleanly and build succeeds.\n\n**TypeScript Compilation:**\n- `tsc --noEmit` (root + all packages): 0 errors across workspace.\n- `npm run build` all packages: clean compilation, no tsconfig parse errors[2][3].\n\n**Linting & Tooling:**\n- `npm run lint libs/ui libs/shared`: 0 parserOption/project config errors[1].\n- VS Code: Open Toast.tsx, verify no red squiggles on imports, TS server recognizes workspace paths[2].\n\n**Toast Functionality Post-Fix:**\n- Manual: Trigger toasts from PrepChef TaskCard (pending Task 20 impl), verify display/undo works.\n- Unit: `npm test libs/ui libs/shared` passes.\n- Storybook: `npm run storybook libs/ui` loads Toast stories without TS errors.\n\n**Regression Prevention:**\n- Run `scripts/validate-edit-tool.js` dry-run: passes for known edit patterns.\n- CI pipeline: All TypeScript/lint checks green on PR.",
        "status": "deferred",
        "dependencies": [
          "20"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-12-19T04:43:24.069Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-19T04:43:24.070Z",
      "taskCount": 12,
      "completedCount": 2,
      "tags": [
        "master"
      ]
    }
  },
  "ui-ux": {
    "tasks": [
      {
        "id": 11,
        "title": "Implement PrepChef single-tap primary action flow with WCAG-compliant touch targets",
        "description": "Redesign PrepChef mobile task interactions to use a single primary action per task, ensure all touch targets meet the 44px WCAG 2.1 AA minimum, and wire these actions to real backend APIs instead of simulated behavior.",
        "details": "Owner: @ui-ux (primary), @business-logic\nComplexity: 7/10\n\nScope & Files:\n- Target the PrepChef mobile app within the Turbo monorepo, e.g. `apps/prepchef-mobile/`.\n- Identify all main task interaction screens and components, e.g. `screens/TaskListScreen.tsx`, `screens/TaskDetailScreen.tsx`, `components/TaskCard.tsx`, `components/PrimaryActionButton.tsx`.\n\nFunctional Requirements:\n- Replace multiple competing action buttons on a task (e.g. Start, Pause, Done, More) with a single context-aware **primary action button** per task card and in the task detail view.\n- Ensure all interactive elements (buttons, list items, icons that trigger actions) have a minimum hit area of 44x44px while preserving existing layouts as much as possible.\n- All task state transitions must call the real Supabase-backed APIs, preserving existing API contracts; remove or gate any simulated behavior behind feature flags.\n- Maintain backward compatibility with existing data and workflows.\n- Latency requirement: touch interactions must render visual feedback (pressed state) within 100ms.\n\nImplementation Notes:\n- Use existing design system components from `@codemachine/ui` such as `Button`, `IconButton`, `Touchable`, updating sizing props to meet 44px targets.\n- Where icons are used as interactive controls, wrap them with a touchable container that enforces min width/height and increased padding.\n- Implement a state machine or simple mapping for the primary action per task status, for example:\n```ts\n// apps/prepchef-mobile/domain/taskActions.ts\nexport type TaskStatus = 'pending' | 'in_progress' | 'paused' | 'completed';\n\nexport type PrimaryAction = {\n  label: string;\n  icon: IconName;\n  nextStatus: TaskStatus;\n};\n\nexport const primaryActionForStatus: Record<TaskStatus, PrimaryAction> = {\n  pending:   { label: 'Start',  icon: 'play',  nextStatus: 'in_progress' },\n  in_progress: { label: 'Pause',  icon: 'pause', nextStatus: 'paused' },\n  paused:    { label: 'Resume', icon: 'play',  nextStatus: 'in_progress' },\n  completed: { label: 'Reopen', icon: 'undo',  nextStatus: 'in_progress' },\n};\n\nexport async function updateTaskStatus(taskId: string, nextStatus: TaskStatus) {\n  const { data, error } = await supabase\n    .from('tasks')\n    .update({ status: nextStatus })\n    .eq('id', taskId)\n    .select()\n    .single();\n  if (error) throw error;\n  return data;\n}\n```\n- Integrate the above helper in `TaskCard` and `TaskDetailScreen` primary button handlers.\n- Use the existing feature flag system (Flagsmith) to gate the new single-tap flow, e.g. `flags.prepchef_single_tap_flow`, to allow rollback.\n- Ensure all components remain server-side renderable (no client-only APIs during initial render; gate them behind `useEffect` or dynamic import with `ssr: false` if strictly necessary, keeping SSR for main screens).\n\nAccessibility & Performance:\n- Confirm minimum touch target by using design tokens for spacing/sizing that map to >=44px on target devices (tablet DPIs used in kitchens).\n- Avoid adding heavy libraries; keep any added computations O(1) per rendered task card to avoid jank.\n\nAcceptance Criteria:\n- 100% of interactive elements on main PrepChef task screens have hit areas >=44x44px (verified via design token mapping and manual inspection).\n- Each task shows exactly one clearly labeled primary action in list and detail views, with correct state transitions.\n- All primary actions call existing Supabase APIs with no simulated/no-op actions remaining on critical paths.\n- Interaction feedback appears within 100ms on representative kitchen tablets.\n- Feature can be toggled on/off via Flagsmith without breaking legacy flows.",
        "testStrategy": "Owner: @qa-automation\n\nAutomated Tests:\n- Add unit tests for `primaryActionForStatus` and `updateTaskStatus` in `apps/prepchef-mobile/domain/__tests__/taskActions.test.ts`.\n- Add integration tests with React Native Testing Library for `TaskCard` and `TaskDetailScreen` to verify that the correct primary action is rendered for each status and that pressing it calls the API with the expected payload.\n\nManual Tests:\n- On real kitchen tablets, navigate through the PrepChef main task lists and detail views and confirm that all touch targets can be reliably tapped with a thumb and visually meet or exceed 44px.\n- Use Chrome DevTools/React Native devtools with device emulation to verify clickable area bounding boxes.\n- Flip the `prepchef_single_tap_flow` feature flag on/off and verify that:\n  - With flag ON: single primary action flow is active and functional.\n  - With flag OFF: legacy multi-button flow functions as before.\n\nRegression & Performance:\n- Measure tap-to-visual-feedback latency with profiling tools; confirm <=100ms on test devices.\n- Run a smoke test of key PrepChef flows (view tasks, start, pause, complete) to ensure no API errors or data integrity issues.\n- Verify server-side rendering of screens still completes successfully in the monorepo build.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Audit and update touch targets to 44px across TaskListScreen, TaskDetailScreen, TaskCard",
            "description": "Review all interactive elements in specified screens and components, update sizing, padding using design system tokens to ensure minimum 44x44px hit areas while preserving layouts.",
            "dependencies": [],
            "details": "Target files: screens/TaskListScreen.tsx, screens/TaskDetailScreen.tsx, components/TaskCard.tsx, components/PrimaryActionButton.tsx. Use @codemachine/ui Button, IconButton, Touchable with min width/height props and increased padding for icons. Verify on kitchen tablet DPIs.\n<info added on 2025-12-18T07:40:18.294Z>\nCompleted UI updates for Button component to support WCAG 44px touch targets.\n\nDetails:\n- File: libs/ui/src/components/Button.tsx\n- Changes: added size prop ('sm' | 'md' | 'lg' with lg = h-12 = 48px), fullWidth prop (responsive full-width on mobile), minTouch prop (enforces 44x44 min hit area), integrated design tokens (ink/graphite/paper), added story in Button.stories.tsx\n- Commit: 6807c78\n- Branch: realtime (pushed to origin/realtime)\n- Tests/Verification: updated Storybook entry for Button; manual inspection validated touch sizing.\n\nOwner: @ui-ux\nSubagent: ui-ux\n\nMarking this subtask as completed and setting status to 'done' per acceptance criteria.\n</info added on 2025-12-18T07:40:18.294Z>",
            "status": "done",
            "testStrategy": "Manual inspection with React Native Inspector hit area tool; design token mapping verification; screenshot comparisons pre/post update."
          },
          {
            "id": 2,
            "title": "Implement primaryActionForStatus state machine and Supabase API integration",
            "description": "Create taskActions.ts with status-to-action mapping and real Supabase updateTaskStatus function, integrate into TaskCard and TaskDetailScreen primary button handlers.",
            "dependencies": [
              1
            ],
            "details": "Implement exact code structure from notes: TaskStatus type, PrimaryAction type, primaryActionForStatus record, async updateTaskStatus using supabase.from('tasks').update(). Integrate in button onPress handlers with visual feedback within 100ms using pressed state.",
            "status": "done",
            "testStrategy": "Unit tests for primaryActionForStatus mapping and updateTaskStatus error handling; mock Supabase integration tests."
          },
          {
            "id": 3,
            "title": "Integrate Flagsmith feature flag gating and backward compatibility",
            "description": "Gate new single-tap flow behind flags.prepchef_single_tap_flow, preserve legacy multi-button flows when flag off, ensure SSR compatibility by gating APIs in useEffect.",
            "dependencies": [
              2
            ],
            "details": "Use existing Flagsmith SDK, conditional rendering of primary button vs legacy buttons. Gate Supabase calls behind flag and useEffect/dynamic imports (ssr: false if needed). Maintain data/workflow compatibility.",
            "status": "done",
            "testStrategy": "Integration tests toggling flag on/off verifying correct UI and no regressions; SSR hydration mismatch checks."
          },
          {
            "id": 4,
            "title": "Add comprehensive tests and performance validation for 100ms feedback",
            "description": "Implement unit/integration tests for components and APIs, validate interaction latency, confirm WCAG touch targets and state transitions meet acceptance criteria.",
            "dependencies": [
              3
            ],
            "details": "Unit tests: taskActions.test.ts for mapping/API. Integration: React Native Testing Library for TaskCard/TaskDetailScreen verifying single primary action, correct transitions. Performance: measure pressed state render time on devices. Axe tests for accessibility.",
            "status": "done",
            "testStrategy": "Automated: jest-axe for violations, RNTL for interactions, performance profiling. Manual: 44px hit verification, 100ms feedback on kitchen tablets, Flagsmith toggle validation."
          }
        ]
      },
      {
        "id": 12,
        "title": "Implement PrepChef toast notifications with undo support and real-time backend integration",
        "description": "Add a unified toast feedback system to PrepChef mobile with undo functionality for key actions, fully integrated with the Supabase backend and feature flags for safe rollout.",
        "details": "Owner: @business-logic (primary), @ui-ux\nComplexity: 6/10\n\nScope & Files:\n- Target feedback/notification layer in `apps/prepchef-mobile/`, e.g. `providers/ToastProvider.tsx`, `hooks/useToast.ts`, `components/Toast.tsx`.\n- Integrate with task actions and other critical flows (e.g. task completion, cancellation).\n\nFunctional Requirements:\n- Show non-blocking **toast messages** for user actions (task status changes, errors, network issues) with succinct descriptions.\n- For reversible actions (e.g. marking a task as completed), provide an **Undo** affordance within the toast for a limited time window (e.g. 5–10 seconds).\n- Undo must be **fully backed by Supabase**: the system must revert the previous change in the database, not just in local UI state.\n- Preserve current API contracts and data model; do not add breaking changes.\n- Ensure no simulated (client-only) operations remain for the supported flows.\n\nImplementation Notes:\n- Prefer using any existing notification components from `@codemachine/ui` (e.g. `Toast`, `Banner`) and extend them if necessary in `@codemachine/ui` instead of forking new patterns.\n- Implement a ToastContext with API like:\n```ts\n// apps/prepchef-mobile/providers/ToastProvider.tsx\nexport interface ToastOptions {\n  id?: string;\n  message: string;\n  type?: 'success' | 'error' | 'info';\n  actionLabel?: string; // e.g. 'Undo'\n  onAction?: () => Promise<void> | void;\n  durationMs?: number;\n}\n\nconst ToastContext = createContext<{ showToast: (opts: ToastOptions) => void } | null>(null);\n```\n- Wire `showToast` into task action handlers (from Task 11). Example pattern:\n```ts\nasync function onPrimaryActionPress(task: Task) {\n  const prevStatus = task.status;\n  const action = primaryActionForStatus[task.status];\n  try {\n    const updated = await updateTaskStatus(task.id, action.nextStatus);\n    showToast({\n      message: `Task ${action.label.toLowerCase()}ed`,\n      type: 'success',\n      actionLabel: 'Undo',\n      onAction: async () => {\n        await updateTaskStatus(task.id, prevStatus);\n      },\n      durationMs: 8000,\n    });\n  } catch (e) {\n    showToast({ message: 'Failed to update task', type: 'error' });\n  }\n}\n```\n- Use Flagsmith flag, e.g. `prepchef_toast_undo`, to enable/disable undo functionality without removing the base toast system.\n- Ensure the component tree remains SSR-compatible; do not access `window` at module top-level.\n\nAccessibility & Performance:\n- Ensure toast is announced to assistive technologies using ARIA live regions (for web builds) or platform-specific accessibility announcements for native.\n- Keep the toast rendering lightweight; limit the number of concurrent toasts and cap updates per second.\n\nAcceptance Criteria:\n- Successful actions surface a toast within 200ms of completion, describing the outcome.\n- Undo is available for at least all task status changes that are reversible and correctly reverts backend state on Supabase.\n- No simulated state-only undos; database reflects final state after undo or timer expiry.\n- Feature is controllable via Flagsmith and is fully backward compatible when disabled.\n- Toast appearance and interaction patterns are consistent with the design system guidelines.\n<info added on 2025-12-18T08:12:45.590Z>\nOwner update:\n- Front-end implementation lead: subagent: ui-ux (coordinate with @ui-ux and reference accessibility patterns from Task 13.1).\n- Backend coordination: collaborate with @project-wiring for Supabase undo RPC/endpoint design and integration.\n\nAdditional scope and files (web/PrepChef app-level):\n- apps/prepchef/components/Toast.tsx: Implement an accessible Toast component supporting message, optional title and description, optional action/undo label, undo callback, dismiss button, visual timer/progress, motion/entry-exit patterns, and variants (e.g., success, error, info). Use appropriate ARIA roles and aria-live attributes to announce toast content and the presence of an available Undo action. Ensure interactive elements are fully keyboard reachable and screen-reader friendly.\n- apps/prepchef/contexts/ToastContext.tsx: Implement ToastProvider and useToast hook managing a toast queue and timers. Expose API: showToast({ title, description, actionLabel, onUndo, duration, variant }) returning a toast id. Maintain an internal undo registry (mapping toast ids to undo callbacks/state) and handle optimistic updates + revert callbacks. Manage maximum concurrent toasts and efficient timer updates to avoid layout jank.\n- apps/prepchef/app/layout.tsx: Wrap the root with ToastProvider and render a toast portal/container at the app shell level so all routes can enqueue toasts.\n- apps/prepchef/components/TaskCard.tsx: Wire task operations (complete, assign, combine, and similar reversible actions) to useToast() and show undo-capable toasts around Supabase-backed operations.\n\nIntegration and backend behavior:\n- Use optimistic UI for task operations (e.g., complete, assign, combine): update UI immediately, then call Supabase APIs to commit the action.\n- On toast Undo action, call a dedicated backend RPC/endpoint that can deterministically revert the original change (e.g., revert status, unassign, uncombine). Do not rely on client-only state for undo; final state must always reflect Supabase.\n- Create a follow-up/handoff task (assigned to @project-wiring) to define and implement the required Supabase undo RPCs/endpoints for supported operations, including clear contracts for idempotent, deterministic undo semantics.\n\nFeature flag behavior:\n- Gate undo-capable toast functionality behind flags.prepchef_toast_undo.\n- When flags.prepchef_toast_undo is enabled:\n  - Expose Undo UI (action button/shortcut), register undo callbacks, and allow full optimistic + revert flows.\n- When flags.prepchef_toast_undo is disabled:\n  - Show basic toasts (success/error/info) without Undo buttons or undo registry usage, while preserving all existing behavior and avoiding runtime errors.\n- Ensure feature flag checks are SSR-safe and do not access window/document at module scope.\n\nAccessibility requirements:\n- Use appropriate ARIA attributes:\n  - role=\"status\" / aria-live=\"polite\" for non-critical info toasts.\n  - role=\"alert\" / aria-live=\"assertive\" for errors or critical feedback.\n- Announce:\n  - Toast message and description.\n  - Availability of an Undo action (e.g., “Action completed. Undo available for 5 seconds.” where appropriate).\n  - Results of undo attempts and failures (e.g., “Undo failed. Please retry or contact support.”).\n- Keyboard behavior:\n  - Do not steal focus by default when a toast appears; allow users to stay in their current context.\n  - Make interactive toast elements reachable via Tab order; allow Enter/Space to activate Undo and Esc to dismiss the toast.\n  - Ensure focus outlines and hit areas meet WCAG 2.1 AA requirements.\n- Verify accessibility via:\n  - A11y snapshots and Chrome DevTools accessibility tree verification for all toast states (initial show, with Undo, after undo success/failure).\n  - Alignment with cross-app accessibility patterns defined in Task 13.1.\n\nTesting & QA additions:\n- Playwright E2E tests (in packages/e2e-tests/ or app-specific E2E location) to cover:\n  - Optimistic update + successful undo flow for task operations (e.g., complete → toast appears → Undo → state reverts both in UI and Supabase mock).\n  - Failure modes:\n    - Backend commit failure: show error toast and ensure UI reflects backend state.\n    - Backend undo failure: show clear failure toast with any available recovery hint (e.g., retry or manual correction).\n  - Feature flag behavior (prepchef_toast_undo on/off) and correct presence/absence of Undo UI.\n- Accessibility snapshot tests:\n  - Capture Chrome DevTools accessibility tree output for all toast variants (success, error, undo-available, undo-failed) and validate expected roles, names, and descriptions.\n- Unit/integration tests:\n  - ToastContext queueing, timers, id generation, and undo registry (including removal after timeout or after undo).\n  - Keyboard interaction on Toast component (Tab reachability, Enter/Space activation, Esc dismissal).\n- Performance validation:\n  - Ensure toast queue and timers are implemented efficiently (e.g., batched state updates, minimal re-renders).\n  - Confirm no noticeable layout jank or frame drops when multiple toasts are enqueued quickly.\n\nUpdated acceptance criteria (Task 12):\n- Toast system implemented with undo support, including:\n  - Accessible Toast component in apps/prepchef/components/Toast.tsx.\n  - ToastProvider and useToast hook with undo registry and queue management.\n- Integrated with Supabase backend APIs for commit and undo semantics, with a documented handoff/child task for backend RPC implementation by @project-wiring.\n- Feature flag gating via flags.prepchef_toast_undo implemented and verified (Undo UI and behavior only when flag is enabled; base toasts always available).\n- Accessibility compliance:\n  - Correct ARIA roles/aria-live usage.\n  - Keyboard-accessible toast interactions (Tab/Enter/Space/Esc).\n  - Screen reader announcements for normal actions, undo availability, and undo success/failure.\n- Robust error handling and user feedback for both primary operations and undo attempts, with clear messaging and suggested next steps where possible.\n- No regressions or performance issues introduced by toast queueing and timers.\n\nNew subtasks to add under Task 12:\n1) Component: Accessible Toast.tsx implementation with motion\n   - Implement Toast UI in apps/prepchef/components/Toast.tsx with variants, timer/progress, dismiss/undo actions, ARIA/aria-live attributes, and entry/exit motion aligned with design system guidelines.\n\n2) Context: ToastContext.tsx with undo registry and API\n   - Implement apps/prepchef/contexts/ToastContext.tsx providing ToastProvider and useToast, managing a toast queue, timers, and undo registry, with showToast({ title, description, actionLabel, onUndo, duration, variant }) → toastId.\n\n3) Layout: Add ToastProvider and portal to app layout\n   - Update apps/prepchef/app/layout.tsx to wrap the app in ToastProvider and render the toast portal/container at the root.\n\n4) TaskCard: Hook up toasts with undo-capable task actions\n   - Update apps/prepchef/components/TaskCard.tsx to use useToast() around task operations (complete, assign, combine, etc.), implementing optimistic UI plus Supabase-backed undo where reversible.\n\n5) Feature flag gating and behavior\n   - Integrate flags.prepchef_toast_undo to conditionally enable Undo UI/behavior while always allowing basic toasts, ensuring SSR-safe flag usage.\n\n6) Tests: Playwright E2E and accessibility snapshots\n   - Add Playwright E2E tests and Chrome DevTools-based accessibility snapshot tests covering optimistic operations, undo flows, error states, and feature-flagged behavior.\n\n7) Backend handoff: Supabase undo RPC/endpoint task\n   - Create a dependent task for @project-wiring to implement and document Supabase undo RPCs/endpoints used by the toast Undo callbacks, including contract details and error semantics.\n\n8) Documentation and Storybook\n   - Add documentation and Storybook stories for the Toast component, ToastProvider/useToast API, and example task flows with undo, including a11y notes and feature-flag behavior.\n\nStatus update:\n- Set Task 12 status to in-progress and assign subagent: ui-ux as the responsible engineer for the front-end implementation, with coordination required with @project-wiring for backend APIs.\n</info added on 2025-12-18T08:12:45.590Z>",
        "testStrategy": "Owner: @qa-automation\n\nAutomated Tests:\n- Unit tests for ToastContext and `useToast` hook in `apps/prepchef-mobile/providers/__tests__/ToastProvider.test.tsx`:\n  - Verify that calling `showToast` renders a toast with correct message and type.\n  - Simulate clicking the `Undo` action and assert that the provided `onAction` callback is called.\n- Integration tests for task undo behavior:\n  - Mock Supabase `updateTaskStatus` and assert that it is called first with `nextStatus` and then with `prevStatus` when undo is activated.\n\nManual Tests:\n- In PrepChef on a test device, trigger each primary action (start/pause/resume/complete) and confirm a toast appears with expected text and an Undo button where applicable.\n- Trigger multiple actions in quick succession to ensure toasts stack or replace each other gracefully and do not block core UI.\n- Use assistive technology (screen reader) to confirm that toast content is announced.\n\nRegression & Performance:\n- Confirm that enabling/disabling `prepchef_toast_undo` via Flagsmith does not cause runtime errors and that base flows still work.\n- Monitor for dropped frames when many toasts appear; verify no perceivable impact on scrolling or tap responsiveness.\n- Run a short UAT session with at least 3 kitchen staff to validate that the feedback and undo behavior are clear and useful; capture issues for subsequent fixes.",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement ToastContext, Provider, and base toast UI with undo-capable actions",
            "description": "Create a shared ToastContext/Provider in apps/prepchef-mobile that exposes a showToast API with undo-capable actions, backed by existing @codemachine/ui toast components.",
            "dependencies": [],
            "details": "1) Add ToastOptions interface and ToastContext to apps/prepchef-mobile/providers/ToastProvider.tsx matching the specified API (message, type, actionLabel, onAction, durationMs, optional id). 2) Implement ToastProvider that manages a small in-memory queue of active toasts, handles auto-dismiss via timers, and renders a toast list using existing @codemachine/ui components (e.g. Toast/Banner) or minimal wrappers in apps/prepchef-mobile/components/Toast.tsx. 3) Ensure onAction supports async functions and that the toast UI disables the action button while the undo action is running and handles errors (e.g. show error toast). 4) Create a hooks/useToast.ts hook that reads ToastContext and throws or no-ops if used outside the provider. 5) Ensure SSR-compatibility by avoiding window access at module top-level and only interacting with timers/effects inside React hooks. 6) Keep the visual design aligned with design system tokens (colors, typography, spacing) and support basic variants for success, error, and info.",
            "status": "pending",
            "testStrategy": "Add unit tests in apps/prepchef-mobile/providers/__tests__/ToastProvider.test.tsx to verify that: (a) calling showToast renders a toast with the provided message and type, (b) toasts auto-dismiss after durationMs, (c) passing an actionLabel and onAction wires the button and triggers onAction on press, including proper handling of async promises and error paths."
          },
          {
            "id": 2,
            "title": "Wire toast notifications with Supabase-backed undo into task action handlers",
            "description": "Connect the toast system to task action handlers so that task status changes and related flows surface toasts with Supabase-backed undo that reverts the backend state.",
            "dependencies": [
              1
            ],
            "details": "1) In task action handlers implemented for Task 11 (e.g. in apps/prepchef-mobile/domain/taskActions and UI components like TaskCard, TaskDetailScreen, PrimaryActionButton), inject useToast and call showToast on successful Supabase-backed status changes. 2) Follow the provided onPrimaryActionPress pattern: capture prevStatus, execute updateTaskStatus(task.id, action.nextStatus), then display a success toast with an Undo action that calls updateTaskStatus(task.id, prevStatus) using the same Supabase API, ensuring no client-only simulated state remains. 3) Ensure all reversible task status transitions (e.g. completed, cancelled, started) use the undo pattern, while irreversible actions omit undo. 4) Handle failures by showing error toasts when updateTaskStatus or undo fails, preserving existing API contracts and models. 5) Confirm final task state always matches Supabase after either undo execution or toast timeout expiry, and that no stale optimistic-only state persists in the UI.",
            "status": "pending",
            "testStrategy": "Extend existing tests in apps/prepchef-mobile/domain/__tests__/taskActions.test.ts and relevant component tests to: (a) mock updateTaskStatus and verify success toasts are shown on completion, (b) simulate tapping Undo and assert updateTaskStatus is called with the previous status, (c) verify that when undo fails, an error toast is displayed and the task state reflects the backend outcome."
          },
          {
            "id": 3,
            "title": "Add accessibility, feature-flag control, tests, and performance limits for toast undo system",
            "description": "Implement ARIA/accessibility behavior, Flagsmith-based undo gating, automated tests, and safeguards for concurrent toast performance in the PrepChef toast system.",
            "dependencies": [
              1,
              2
            ],
            "details": "1) Integrate Flagsmith flag (e.g. prepchef_toast_undo) so that undo actions and UI are conditionally enabled while the base toast notifications remain available when the flag is off; ensure backward compatibility and safe rollout paths. 2) For web builds, ensure toasts are exposed via ARIA live regions (e.g. role=\"status\" or aria-live=\"polite\"/\"assertive\" as appropriate), and for native builds use platform-specific accessibility announcements so screen readers receive toast messages. 3) Add limits on the number of concurrent visible toasts (e.g. max N stacked toasts, dropping or merging extras) and ensure timer and state updates are throttled to avoid excessive re-renders. 4) Validate that toast appearance and interaction patterns match design system guidelines (spacing, motion, colors) and remain consistent across platforms. 5) Confirm no SSR issues are introduced by feature flag checks or accessibility hooks (e.g. guard against window/document usage at module scope).",
            "status": "pending",
            "testStrategy": "Add automated tests to cover: (a) feature-flag behavior where prepchef_toast_undo off hides Undo affordances but still shows success/error toasts, (b) ARIA live attributes are present in web snapshots using React Testing Library and jest-axe to ensure no critical accessibility violations for toast markup, and (c) performance constraints such as enforcing a cap on the number of rendered toasts and verifying that adding more toasts beyond the limit does not increase the rendered count."
          }
        ]
      },
      {
        "id": 13,
        "title": "Implement cross-platform WCAG 2.1 AA accessibility baseline (keyboard, focus, ARIA)",
        "description": "Establish a shared accessibility layer and patterns to achieve WCAG 2.1 AA compliance across PrepChef, Admin CRM, and Display, focusing on keyboard navigation, focus management, and ARIA semantics.",
        "details": "Owner: @ui-ux (primary), @business-logic\nComplexity: 8/10\n\nScope & Files:\n- Shared UI library: `packages/@codemachine/ui/` (buttons, inputs, dialogs, modals, lists, toasts, DnD).\n- App-level accessibility configs:\n  - `apps/admin-crm-web/` (web dashboard).\n  - `apps/display-kiosk/` (kiosk web app).\n  - `apps/prepchef-mobile/` web/native bridges as applicable.\n\nFunctional Requirements:\n- Ensure **full keyboard navigation** on web apps (Admin CRM, Display) for all interactive elements.\n- Implement consistent **focus management**: visible focus indicators, logical tab order, and focus trapping in modals/overlays.\n- Add missing **ARIA labels/roles** to interactive components and status messages.\n- Integrate automated accessibility testing (axe-core) into CI (high-level wiring; detailed testing suite in Task 20 analog later, partially here).\n\nImplementation Notes:\n- In `@codemachine/ui`:\n  - Update `Button`, `IconButton`, `Link`, `Input`, `Checkbox`, `Select`, `Dialog`, etc. to:\n    - Forward `aria-*` props.\n    - Ensure correct `role` and `tabIndex` (default 0 for interactive elements not naturally focusable).\n    - Provide visible `:focus-visible` styles using design tokens.\n- Implement a `FocusScope` or reuse an existing one to trap focus inside modals/drawers.\n- Provide helper components/hooks, e.g. `useAriaLive`:\n```ts\n// packages/@codemachine/ui/src/hooks/useAriaLive.tsx\nexport function useAriaLive(regionId = 'cm-aria-live') {\n  const [message, setMessage] = useState('');\n  // Render a visually hidden live region at app root via a provider.\n  return { announce: setMessage };\n}\n```\n- For Admin CRM pages (e.g. `apps/admin-crm-web/pages/**/*.tsx`):\n  - Ensure headings follow a proper hierarchy (h1, h2, h3).\n  - Ensure landmark roles (`main`, `nav`, `header`, `footer`) are present.\n  - Audit all forms to ensure labels are linked to inputs (`htmlFor`/`id` and `aria-labelledby`).\n- For Display kiosk:\n  - Ensure kiosk elements that are interactive or informational for assistive tech have correct roles and labels, even if typically touch-only.\n- Introduce axe-core checks in web test setup, e.g. `apps/admin-crm-web/tests/accessibility.test.ts` using `jest-axe`.\n\nAcceptance Criteria:\n- All web UI components used in Admin CRM and Display are keyboard focusable and operable (no mouse-only interactions).\n- Visible focus indicator meets contrast and visibility expectations across themes.\n- Screen readers correctly announce:\n  - Link and button labels.\n  - Form field labels and error messages.\n  - Toasts and status messages via aria-live.\n- axe-core baseline scans on key flows show no critical violations and pass at least 95% WCAG 2.1 AA checks by count.\n- No degradation in performance greater than 5% in measured page load or interaction timing metrics.",
        "testStrategy": "Owner: @qa-automation\n\nAutomated Tests:\n- Add `jest-axe` tests for representative pages/components in Admin CRM and Display (e.g. dashboard page, main kiosk screen) ensuring `expect(await axe(container)).toHaveNoViolations()` for critical violations.\n- Add unit tests in `@codemachine/ui` verifying that:\n  - `Button` forwards `aria-label` and `aria-describedby`.\n  - `Dialog` correctly traps focus and restores it on close.\n\nManual Tests:\n- Keyboard-only walkthroughs on Admin CRM and Display:\n  - Verify tab/shift+tab order is logical and cyclical in modals.\n  - Confirm that all functionality is available without a mouse.\n- Screen reader passes (NVDA/JAWS/VoiceOver) on:\n  - Admin CRM main dashboard.\n  - At least one critical data entry form.\n  - Main kiosk display screen.\n\nRegression & Performance:\n- Run Lighthouse accessibility audits on key pages and capture scores; confirm >=95 for accessibility.\n- Use browser devtools performance panel to verify that added accessibility props/styles do not introduce noticeable layout thrash or script overhead.\n- Ensure SSR output remains valid HTML with correct ARIA attributes and no hydration warnings.",
        "priority": "high",
        "dependencies": [],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Update shared @codemachine/ui components with ARIA and focus props",
            "description": "Enhance UI components like Button, Input, Dialog, etc., to forward aria-* props, set correct roles/tabIndex, and add visible :focus-visible styles using design tokens.",
            "dependencies": [],
            "details": "Target packages/@codemachine/ui/src/components/ (Button, IconButton, Link, Input, Checkbox, Select, Dialog, etc.). Ensure tabIndex=0 for interactive elements, forwardRef for aria props, and CSS focus styles meeting WCAG contrast. Update TypeScript interfaces to include aria props.",
            "status": "pending",
            "testStrategy": "Add unit tests with jest-axe for each updated component: render with aria-label and assert no violations; test focus styles with @testing-library/react."
          },
          {
            "id": 2,
            "title": "Implement focus trapping and management for modals and overlays",
            "description": "Create or enhance FocusScope component/hook to trap focus inside modals, drawers, and overlays, ensuring logical tab order and escape key handling.",
            "dependencies": [
              1
            ],
            "details": "In packages/@codemachine/ui/src/components/FocusScope.tsx or hooks/useFocusTrap.ts. Use roving tabindex or focus management libs if available; ensure :focus-visible indicators; handle Shift+Tab wraparound.",
            "status": "pending",
            "testStrategy": "E2E tests simulating Tab/Shift+Tab navigation in modals; verify focus doesn't escape; test with keyboard-only navigation using Playwright or Cypress."
          },
          {
            "id": 3,
            "title": "Apply app-level accessibility fixes for Admin CRM and Display apps",
            "description": "Audit and fix headings hierarchy, add landmark roles (main, nav), link form labels to inputs, and ensure ARIA for kiosk elements in Admin CRM and Display.",
            "dependencies": [
              1
            ],
            "details": "Update apps/admin-crm-web/pages/**/*.tsx for h1-h6 order, <main role='main'>, htmlFor/id on labels. For apps/display-kiosk/, add roles/labels to interactive/info elements despite touch-primary.",
            "status": "pending",
            "testStrategy": "Run axe-core scans on key pages (e.g., dashboard); manual keyboard tab through pages verifying logical order; screen reader tests with NVDA/VoiceOver."
          },
          {
            "id": 4,
            "title": "Integrate axe-core and jest-axe into CI and test setups",
            "description": "Wire automated accessibility testing with axe-core into web app CI pipelines and create baseline tests for representative pages/components.",
            "dependencies": [
              1,
              3
            ],
            "details": "Add jest-axe to apps/admin-crm-web/tests/accessibility.test.ts and apps/display-kiosk/; configure in package.json/jest.config.js; run on PRs via turbo/CI; target 95% pass rate.",
            "status": "pending",
            "testStrategy": "Assert expect(await axe(container)).toHaveNoViolations() in tests; monitor CI failures; baseline critical violations only initially."
          },
          {
            "id": 5,
            "title": "Develop aria-live helpers and conduct manual accessibility testing",
            "description": "Implement useAriaLive hook for toasts/status messages; perform comprehensive keyboard, screen reader, and WCAG validation across all apps.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create packages/@codemachine/ui/src/hooks/useAriaLive.tsx as specified; test announcements for toasts/errors. Manual: full keyboard flows, NVDA/JAWS/VoiceOver on buttons/forms/modals, focus indicator contrast checks.",
            "status": "pending",
            "testStrategy": "Manual verification checklist: keyboard operability, screen reader announcements (e.g., button labels, errors), focus visibility across themes; document passes/fails in report."
          }
        ]
      },
      {
        "id": 14,
        "title": "Enhance Display kiosk typography, density, and high-contrast theme for distance readability",
        "description": "Redesign the Display kiosk UI to be legible from 6–10 feet with a kiosk-specific typography scale, reduced visual density, and a high-contrast mode while maintaining 60fps performance.",
        "details": "Owner: @ui-ux\nComplexity: 7/10\n\nScope & Files:\n- Kiosk app: `apps/display-kiosk/`.\n- Shared tokens & themes: `packages/@codemachine/ui/tokens/`, `packages/@codemachine/ui/theme/`.\n\nFunctional Requirements:\n- Define a **kiosk typography scale** with font sizes and line heights that are readable from 6–10 feet.\n- Reduce information density to prioritize key information (e.g. current orders, status) with sufficient spacing.\n- Implement a **high-contrast mode** toggle that significantly increases contrast between foreground and background.\n- Ensure kiosk maintains 60fps under typical operational loads.\n\nImplementation Notes:\n- Extend design tokens for typography:\n```ts\n// packages/@codemachine/ui/tokens/typography.ts\nexport const typography = {\n  kioskHeading: { fontSize: 32, lineHeight: 40 },\n  kioskSubheading: { fontSize: 24, lineHeight: 32 },\n  kioskBody: { fontSize: 20, lineHeight: 28 },\n};\n```\n- In `apps/display-kiosk/components/OrderList.tsx` and main screen components, apply kiosk typography tokens and increased spacing using layout tokens.\n- Simplify layouts to avoid overly dense tables; prefer large rows/cards with clear status indicators.\n- Implement a `kioskHighContrast` theme variant in `@codemachine/ui/theme/` with WCAG AA-compliant color pairs.\n- Add a kiosk-level toggle (feature flag + runtime toggle in admin UI) to switch between default and high-contrast themes, e.g. via context or existing theming hooks.\n- Avoid heavy animations; use simple CSS transitions if needed and keep DOM node count reasonable for 60fps.\n\nAcceptance Criteria:\n- Main kiosk screen text (headings and primary data) is readable from at least 8 feet in a controlled test.\n- High-contrast mode yields contrast ratios meeting or exceeding WCAG 2.1 AA thresholds for text and UI components.\n- Kiosk app scrolls and updates at or near 60fps on target kiosk hardware during simulated busy periods.\n- Typography and spacing changes are implemented via shared tokens so they can be reused and managed centrally.\n<info added on 2025-12-18T08:14:13.448Z>\n**Subagent Assignment:** ui-ux  \n**Status Update:** in-progress (started immediately in parallel)  \n\n**Updated Scope & Files:**  \n- apps/display/components/SummaryGrid.tsx: Apply kiosk typography tokens to heading and primary data elements, ensure spacing and layout for distance readability.  \n- apps/display/components/UrgentTicker.tsx: Ensure large, bold text for urgent messages with clear contrast; consider motion patterns that do not harm readability or induce motion sickness.  \n- libs/ui/src/components/KioskLayout.tsx: New kiosk-specific layout component providing expanded spacing, larger hit targets, and theme support for high-contrast mode.  \n- Update design tokens: Add kiosk-specific typography and spacing tokens in libs/ui/src/theme/tokens/typography.ts and spacing tokens.  \n\n**Additional Implementation Notes:**  \n- Add kiosk tokens: kioskHeading: 32px/40lh, kioskSubheading: 24px/32lh, kioskBody: 20px/28lh; spacing tokens (kioskSpacingLarge: 24px, kioskSpacingMedium: 16px).  \n- Implement high-contrast theme variant in libs/ui theme, using accessible color pairs that meet WCAG 2.1 AA.  \n- KioskLayout should accept a highContrast boolean and a density prop (default 'reduced') to control layout and theme.  \n- Use CSS variables and Tailwind tokens to allow runtime toggling without rebuild.  \n- Coordinate with @ui-ux and reference accessibility patterns from Task 13.1. Ensure tokens and theme updates are reusable across apps.  \n\n**Additional Accessibility & Testing Notes:**  \n- Ensure text contrast ratios meet AA requirements using color-contrast checks.  \n- Provide Storybook stories demonstrating default vs kiosk vs high-contrast variants.  \n- Add performance check strategy: ensure 60fps under simulated load.  \n\n**New Subtasks:**  \n1) Tokens: Add kiosk typography and spacing tokens in libs/ui/src/theme/tokens  \n2) Layout: Implement KioskLayout component in libs/ui/src/components/KioskLayout.tsx  \n3) Display updates: Update SummaryGrid.tsx and UrgentTicker.tsx to use new tokens and layout  \n4) Theme: Add high-contrast theme variant and runtime toggle, wire to KioskLayout  \n5) Testing & stories: Storybook stories, contrast checks, and performance tests\n</info added on 2025-12-18T08:14:13.448Z>",
        "testStrategy": "Owner: @qa-automation\n\nManual Tests:\n- Conduct a distance readability test: open the main kiosk screens on a kiosk display and verify that core information (order number, status, timing) is readable and distinguishable at 8–10 feet for multiple testers.\n- Verify high-contrast mode:\n  - Toggle on and off and confirm all screens update colors correctly.\n  - Use color contrast analysis tools to confirm AA compliance.\n\nAutomated / Performance Tests:\n- Use browser performance profiling on kiosk screens under load (simulated frequent order updates) and verify frame rate is ~60fps with no long tasks >50ms.\n- Add visual regression tests (e.g. via Storybook + screenshot testing) for default vs high-contrast themes to prevent accidental regressions.\n\nAccessibility Tests:\n- Run axe-core on kiosk screens to ensure the new theme and typography do not introduce accessibility violations.\n- Verify that contrast ratios remain compliant in both light and high-contrast themes.",
        "priority": "high",
        "dependencies": [
          13
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define kiosk-specific typography and layout tokens",
            "description": "Create and extend design tokens in @codemachine/ui for kiosk typography scale (font sizes/line heights readable from 6-10ft) and increased spacing to reduce density, based on kiosk UX best practices for large, legible fonts and ample whitespace.",
            "dependencies": [],
            "details": "Update packages/@codemachine/ui/tokens/typography.ts with kioskHeading (32px/40lh), kioskSubheading (24px/32lh), kioskBody (20px/28lh); add layout tokens for spacing (e.g. kioskSpacingLarge: 24px). Ensure tokens support distance readability per WCAG and kiosk guidelines[1][3][7].",
            "status": "pending",
            "testStrategy": "Validate token values against readability specs; visual regression tests on token application; manual check for legibility simulation at 8ft."
          },
          {
            "id": 2,
            "title": "Refactor Display kiosk screens using new tokens and reduce density",
            "description": "Apply kiosk typography/layout tokens to OrderList.tsx and main screens in apps/display-kiosk/; simplify layouts to large rows/cards prioritizing key info (orders/status) with reduced density and sufficient spacing.",
            "dependencies": [
              1
            ],
            "details": "Replace dense tables with spacious cards/rows using kiosk tokens; increase padding/margins via layout tokens; remove non-essential elements per simplicity best practices[1][2][4]. Keep DOM lightweight for perf.",
            "status": "pending",
            "testStrategy": "UI review for density reduction; distance readability test at 8-10ft; measure DOM node count and layout shift."
          },
          {
            "id": 3,
            "title": "Implement high-contrast theme toggle with WCAG validation and perf testing",
            "description": "Add kioskHighContrast theme variant in @codemachine/ui/theme/ with WCAG AA colors; implement runtime toggle via context/feature flag; ensure 60fps under load with simple transitions.",
            "dependencies": [
              1,
              2
            ],
            "details": "Define high-contrast colors meeting WCAG 2.1 AA (contrast >=4.5:1); add admin UI toggle; test perf on kiosk hardware during busy simulations; avoid heavy animations[1][3][5].",
            "status": "pending",
            "testStrategy": "Automated contrast ratio checks (e.g. axe-core); 60fps profiling with React DevTools/Chrome perf; toggle functionality E2E tests; manual WCAG validation."
          }
        ]
      },
      {
        "id": 15,
        "title": "Build Admin CRM operations dashboard with accessible KPIs and bulk operations",
        "description": "Create a comprehensive Admin CRM dashboard that surfaces key kitchen KPIs with clear hierarchy and supports accessible bulk operations on entities (e.g. orders, tasks).",
        "details": "Owner: @business-logic (primary), @ui-ux\nComplexity: 8/10\n\nScope & Files:\n- Admin CRM web app: `apps/admin-crm-web/pages/dashboard.tsx` (or feature module), `components/dashboard/`.\n- Shared UI: `@codemachine/ui` for cards, charts, tables, bulk action bars.\n\nFunctional Requirements:\n- Display primary **operational KPIs** (e.g. orders in progress, average prep time, overdue items, station load) in a clear, prioritized layout.\n- Provide **bulk operations** (e.g. assign, reassign, change status) on relevant resources with proper confirmation and accessibility.\n- Ensure drag-and-drop (DnD) interactions, if used (e.g. reassigning tasks), are accessible and keyboard-operable.\n\nImplementation Notes:\n- Design dashboard layout with sections:\n  - KPI summary row using cards: `KpiCard` component.\n  - Detailed lists/tables for actionable items.\n- Use Supabase queries (respecting existing schema and RLS policies) to fetch KPIs. Example pseudo-query:\n```ts\nconst { data: orders } = await supabase\n  .from('orders')\n  .select('id,status,created_at,completed_at,station_id');\n// Compute metrics in the app or via existing views.\n```\n- Implement `KpiCard` in `@codemachine/ui` if not existing, accepting aria attributes and focus states for keyboard users.\n- For bulk operations:\n  - Use a table or list with checkboxes to select multiple rows.\n  - Provide bulk action bar that appears when one or more items are selected.\n  - Ensure all interactions are available via keyboard and labeled appropriately.\n- For DnD accessibility:\n  - Use or extend any existing DnD utility that supports keyboard navigation.\n  - Provide alternative controls (e.g. dropdowns) to perform equivalent actions without drag-and-drop.\n\nAcceptance Criteria:\n- Dashboard shows at least 3–5 key KPIs, updated in near real time (on refresh or short polling/WS if already present in the system) based on live Supabase data.\n- Bulk operations can be performed on at least one resource type, validated on backend and respecting existing API contracts.\n- Keyboard users can:\n  - Navigate all KPI cards and lists.\n  - Select and operate bulk actions.\n  - Access an alternative to DnD where necessary.\n- Visual hierarchy clearly emphasizes the most important metrics and actions as determined by product/design.",
        "testStrategy": "Owner: @qa-automation\n\nAutomated Tests:\n- Unit/integration tests for `KpiCard` and bulk action components to validate keyboard interaction, ARIA attributes, and selection logic.\n- API integration tests (or contract tests) ensuring that bulk action endpoints are invoked with correct payloads and handle RLS constraints gracefully.\n\nManual Tests:\n- Verify that the dashboard loads KPIs correctly for different roles (e.g. manager vs staff) respecting existing authentication/authorization.\n- Perform bulk operations via mouse and keyboard only, confirming updates persist in Supabase and are reflected in subsequent views.\n- Validate that an equivalent, non-DnD interaction path exists for any DnD-based operation.\n\nAccessibility & UX Tests:\n- Run axe-core scans on the dashboard page to confirm no high-severity issues.\n- Conduct heuristic evaluation with at least one UX reviewer focusing on information hierarchy and clarity.\n- Confirm that focus order through KPI cards and bulk action controls matches visual order and user expectations.",
        "priority": "medium",
        "dependencies": [
          13
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and implement KPI cards and dashboard layout with Supabase queries",
            "description": "Create the KPI summary row using KpiCard components and detailed lists/tables, integrating Supabase queries for real-time operational KPIs like orders in progress and average prep time.",
            "dependencies": [],
            "details": "Implement in apps/admin-crm-web/pages/dashboard.tsx and components/dashboard/. Use @codemachine/ui for cards. Fetch data via Supabase respecting RLS, compute metrics client-side. Ensure prioritized layout with visual hierarchy per best practices[1][2][4].",
            "status": "pending",
            "testStrategy": "Unit tests for KpiCard rendering and Supabase query integration; validate KPI calculations against sample data."
          },
          {
            "id": 2,
            "title": "Build accessible bulk operations with checkboxes and action bar",
            "description": "Implement bulk operations for resources like orders and tasks, including selection checkboxes, bulk action bar, and confirmation dialogs.",
            "dependencies": [
              1
            ],
            "details": "Add table/list with checkboxes in dashboard components. Show action bar on selection for assign/reassign/status change. Use shared UI from @codemachine/ui. Ensure keyboard navigation and ARIA labels for accessibility.",
            "status": "pending",
            "testStrategy": "Integration tests for selection logic, bulk API calls, and keyboard operability using axe-core."
          },
          {
            "id": 3,
            "title": "Add keyboard and DnD alternatives for full WCAG compliance",
            "description": "Ensure all interactions including drag-and-drop are keyboard operable, with alternative controls like dropdowns for reassigning tasks.",
            "dependencies": [
              1,
              2
            ],
            "details": "Extend DnD utilities for keyboard support. Add ARIA attributes to KpiCard and bulk components. Provide non-DnD alternatives. Test with high contrast and screen readers.",
            "status": "pending",
            "testStrategy": "Axe-core scans, keyboard navigation tests, and manual WCAG 2.1 AA checks for focus management."
          },
          {
            "id": 4,
            "title": "Conduct integration tests, axe-core scans, and role-based validation",
            "description": "Run comprehensive tests including unit/integration, accessibility scans, and validate data with RLS policies.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Cover KpiCard, bulk actions, keyboard/DnD. Test backend validation for bulk ops. Verify role-based data visibility and near real-time updates via polling/WS.",
            "status": "pending",
            "testStrategy": "Automated e2e tests with Playwright/Cypress; API contract tests; RLS policy enforcement checks."
          }
        ]
      },
      {
        "id": 16,
        "title": "Standardize design tokens and shared components in @codemachine/ui",
        "description": "Create a unified design token system and shared component library updates in @codemachine/ui to",
        "status": "pending",
        "priority": "medium",
        "dependencies": [],
        "subtasks": [
          {
            "id": 1,
            "title": "Audit existing tokens and components for inconsistencies",
            "description": "Conduct a comprehensive audit of current design tokens and shared components in @codemachine/ui to identify inconsistencies, duplicates, and gaps across colors, typography, spacing, and components.",
            "dependencies": [],
            "details": "Review packages/@codemachine/ui/tokens/, components/, and usage in apps like admin-crm-web, display-kiosk, prepchef-mobile. Document findings in a report with examples of inconsistencies like varying color values or spacing units. Use tools like grep or linters for code search.",
            "status": "pending",
            "testStrategy": "Manual review: Cross-check audit report against code samples from dependent apps (Task 15,14,11); validate with team stakeholders."
          },
          {
            "id": 2,
            "title": "Define unified typography, color, and spacing tokens",
            "description": "Create a standardized set of design tokens for typography scales, color palette, and spacing system following semantic naming conventions like category.concept.property.",
            "dependencies": [
              1
            ],
            "details": "Base on audit results and project needs (kiosk readability from Task 14, WCAG touch targets from Task 11, high-contrast modes). Use JSON format compatible with W3C spec, ensure accessibility (WCAG AA contrast). Examples: color.background.primary, spacing.inset.medium, typography.heading.kiosk.",
            "status": "pending",
            "testStrategy": "Automated: Build script to validate token references and contrast ratios; manual: Visual diff in Figma/Storybook against audit findings."
          },
          {
            "id": 3,
            "title": "Refactor and update key shared components to use new tokens",
            "description": "Update critical shared UI components in @codemachine/ui (e.g. cards, charts, tables, buttons) to consume the new unified design tokens, removing hardcoded values.",
            "dependencies": [
              2
            ],
            "details": "Prioritize components used in dependent tasks: KPI cards/bulk actions (Task 15), kiosk typography/themes (Task 14), touch targets (Task 11). Use CSS custom properties or Tailwind for token integration. Handle themes like high-contrast mode.",
            "status": "pending",
            "testStrategy": "Unit tests for component rendering with tokens; integration tests in Storybook; visual regression tests pre/post refactor."
          },
          {
            "id": 4,
            "title": "Add documentation, Storybook stories, and regression tests",
            "description": "Document the new token system and updated components, enhance Storybook with interactive examples, and implement tests to prevent regressions.",
            "dependencies": [
              3
            ],
            "details": "Create README.md with token overview, usage guidelines, code snippets per best practices. Add Storybook pages for tokens/components with controls for themes. Include accessibility audits. Publish to Storybook for team review.",
            "status": "pending",
            "testStrategy": "E2E tests simulating app usage (e.g. dashboard KPIs, kiosk screens); Storybook test runner for component isolation; manual accessibility scan with Lighthouse."
          }
        ],
        "details": "",
        "testStrategy": ""
      },
      {
        "id": 17,
        "title": "Implement Playwright WCAG 2.1 AA Accessibility Test Suite Across All Apps",
        "description": "Create a comprehensive Playwright test suite using axe-core to validate WCAG 2.1 AA compliance, keyboard navigation, screen reader compatibility, and performance metrics for touch targets and response times across PrepChef, Admin CRM, and Display applications.",
        "details": "Develop a dedicated Playwright test suite in `packages/e2e-tests/` targeting WCAG 2.1 AA compliance across all three applications using current best practices from Playwright documentation and axe-core integration[1][4].\n\n**Setup and Configuration:**\n- Install dependencies: `npm install --save-dev @playwright/test @axe-core/playwright @axe-core/react` (for React components)[1][3][4].\n- Configure `playwright.config.ts` with projects for each app:\n  ```typescript\n  projects: [\n    { name: 'prepchef-mobile', use: { ...devices['iPhone 14'] } },\n    { name: 'admin-crm-web', use: { viewport: { width: 1280, height: 720 } } },\n    { name: 'display-kiosk', use: { viewport: { width: 1920, height: 1080 } } }\n  ]\n  ```\n- Add axe-core ruleset: `{ runOnly: { type: 'tag', values: ['wcag2a', 'wcag2aa'] } }` for WCAG 2.1 AA focus[2][4].\n\n**Core Test Coverage:**\n1. **Axe-core Automated Scans** (`tests/accessibility/axe-scans.spec.ts`):\n   - Full-page scans on critical paths: login, dashboard, task lists, task details[1][4].\n   ```typescript\nimport { test, expect } from '@playwright/test';\nimport AxeBuilder from '@axe-core/playwright';\n\ntest.describe('Admin CRM Accessibility', () => {\n  test('dashboard should pass WCAG 2.1 AA', async ({ page }) => {\n    await page.goto('/dashboard');\n    const results = await new AxeBuilder({ page })\n      .withTags(['wcag2a', 'wcag2aa'])\n      .analyze();\n    expect(results.violations).toEqual([]);\n  });\n});\n   ```\n   - Component-level scans for shared UI from `@codemachine/ui`[3].\n\n2. **Keyboard Navigation Tests** (`tests/accessibility/keyboard.spec.ts`):\n   - Tab through all interactive elements verifying logical focus order[3][4].\n   - Test `Tab`, `Shift+Tab`, `Enter`, `Space`, `Escape` on buttons, forms, modals.\n   - Skip links and focus management verification per Task 13 patterns.\n   ```typescript\n   await page.keyboard.press('Tab');\n   await expect(page.locator(':focus')).toBeVisible();\n   ```\n\n3. **Screen Reader Compatibility** (`tests/accessibility/screenreader.spec.ts`):\n   - Verify ARIA landmarks, labels, roles using Playwright's `getByRole()`[4].\n   - Test live regions (toasts from Task 12) announce correctly.\n   - Validate `aria-live`, `role='status'`, `role='alert'` on dynamic content.\n\n4. **Touch Target & Performance Tests** (`tests/accessibility/performance.spec.ts`):\n   - Verify 44px minimum touch targets (build on Task 11): `expect(button.boundingBox()).width >= 44`[11].\n   - Response time assertions: `await expect(page.locator('button')).toBeEnabled({ timeout: 300 });`.\n   - Kiosk-specific distance readability checks for Task 14 high-contrast mode.\n\n**App-Specific Coverage:**\n- **PrepChef Mobile**: Task flows, single-tap actions (Task 11), toast notifications (Task 12).\n- **Admin CRM**: Dashboard KPIs (Task 15), bulk operations.\n- **Display Kiosk**: Main screens, high-contrast theme (Task 14).\n\n**Integration Points:**\n- Leverage shared accessibility baseline from Task 13.\n- Use design tokens from Task 16 for consistent testing selectors.\n- CI/CD integration: Run on every PR with `npx playwright test --project=accessibility`.\n\n**Best Practices:**\n- Exclude third-party embeds from scans using `exclude: ['[data-skip-a11y]']`[1].\n- Generate HTML reports: `npx playwright show-report`.\n- Thresholds: Fail on violations, warn on 'needsReview'[2].",
        "testStrategy": "Execute comprehensive verification across multiple dimensions to ensure WCAG 2.1 AA compliance and performance standards[1][3][4].\n\n**Automated Test Execution:**\n- Run full suite: `npx playwright test --project=accessibility` expecting 0 axe-core violations on WCAG 2A/2AA rules.\n- Verify axe reports: `expect(accessibilityScanResults.violations).toEqual([])` for all critical pages[1][4][5].\n- Keyboard tests: Confirm 100% tab coverage reaches all interactive elements without trapping; validate focus indicators visible.\n- Screen reader: Assert all interactive elements have `getByRole()` selectors; live regions announce within 1s.\n- Touch/performance: All buttons/links ≥44px; interactions complete <500ms; kiosk text readable at 1920x1080 scale.\n\n**Manual Validation Checklist:**\n- NVDA/JAWS screen reader: Navigate complete user flows on Admin CRM/Display (verify Task 13 ARIA implementation).\n- VoiceOver (iOS): Test PrepChef mobile task flows (Task 11 single-tap, Task 12 toasts).\n- Distance test: Display kiosk screens legible at 8-10ft (Task 14 high-contrast).\n- Color contrast analyzer on screenshots from high-contrast mode.\n\n**CI/CD Verification:**\n- GitHub Actions: Fail PRs with accessibility violations; post axe-core HTML report as artifact.\n- Coverage report: ≥95% critical path coverage across all three apps.\n- Regression check: Re-run tests post-UI changes (Tasks 14,15,16) to validate no new violations.\n\n**Success Criteria:**\n- 0 critical WCAG 2.1 AA violations across apps.\n- Full keyboard navigation support.\n- Touch targets meet 44px standard.\n- Performance: All interactions <1s response time.",
        "status": "pending",
        "dependencies": [
          11,
          12,
          13,
          14,
          15,
          16
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Playwright configuration and install accessibility dependencies",
            "description": "Install required packages and configure playwright.config.ts with projects for PrepChef, Admin CRM, and Display apps including WCAG 2.1 AA axe-core ruleset.",
            "dependencies": [],
            "details": "Run `npm install --save-dev @playwright/test @axe-core/playwright @axe-core/react`; update playwright.config.ts with specified projects (prepchef-mobile iPhone 14, admin-crm-web 1280x720, display-kiosk 1920x1080) and axe-core configuration { runOnly: { type: 'tag', values: ['wcag2a', 'wcag2aa'] } }. Exclude third-party embeds with 'data-skip-a11y'.[1][4]",
            "status": "pending",
            "testStrategy": "Verify config loads without errors: `npx playwright test --list` shows all projects; manual check config file syntax."
          },
          {
            "id": 2,
            "title": "Implement axe-core WCAG 2.1 AA automated scans for critical paths",
            "description": "Create tests/accessibility/axe-scans.spec.ts performing full-page and component-level axe-core scans on login, dashboard, task lists, task details across all three apps.",
            "dependencies": [
              1
            ],
            "details": "Use AxeBuilder with .withTags(['wcag2a', 'wcag2aa']) on critical paths; expect(results.violations).toEqual([]); include shared UI from @codemachine/ui; generate HTML reports with `npx playwright show-report`.[1][4]",
            "status": "pending",
            "testStrategy": "Run `npx playwright test accessibility/axe-scans.spec.ts` expecting 0 violations on WCAG 2A/2AA rules across all projects."
          },
          {
            "id": 3,
            "title": "Develop keyboard navigation test suite",
            "description": "Create tests/accessibility/keyboard.spec.ts to validate Tab, Shift+Tab, Enter, Space, Escape keys on all interactive elements with logical focus order and skip links.",
            "dependencies": [
              1
            ],
            "details": "Test tab through buttons, forms, modals; verify :focus visibility; implement focus management per Task 13 patterns across PrepChef mobile flows, Admin CRM dashboard, Display kiosk screens.[3][4]",
            "status": "pending",
            "testStrategy": "Manual verification of focus indicators during test execution; assert expect(page.locator(':focus')).toBeVisible() after each keypress."
          },
          {
            "id": 4,
            "title": "Build screen reader compatibility tests",
            "description": "Create tests/accessibility/screenreader.spec.ts verifying ARIA landmarks, roles, labels using getByRole(), live regions, aria-live status/alert on dynamic content like toasts.",
            "dependencies": [
              1
            ],
            "details": "Test ARIA attributes on toasts (Task 12), landmarks, roles; validate dynamic announcements using Playwright's getByRole() API across all apps.[4]",
            "status": "pending",
            "testStrategy": "Assert getByRole('status'), getByRole('alert') exist and have proper labels; verify live region announcements trigger correctly."
          },
          {
            "id": 5,
            "title": "Implement touch targets and performance metrics tests with CI integration",
            "description": "Create tests/accessibility/performance.spec.ts for 44px touch targets, response times, kiosk readability; integrate suite into CI/CD for PR runs.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Assert button.boundingBox().width >= 44; expect(locator).toBeEnabled({timeout:300}); add high-contrast checks for Display (Task 14); run `npx playwright test --project=accessibility` on every PR.[11]",
            "status": "pending",
            "testStrategy": "Execute full suite `npx playwright test --project=accessibility` expecting pass on all apps; fail on violations, warn on needsReview; verify CI integration triggers on PRs."
          }
        ]
      },
      {
        "id": 18,
        "title": "Conduct in-kitchen usability testing of PrepChef mobile with real kitchen staff",
        "description": "Run structured usability testing sessions with real kitchen staff using the PrepChef mobile app in an active kitchen environment to validate task flows, touch interactions, and workflow efficiency, while capturing quantitative UX metrics and qualitative feedback.",
        "details": "**Scope and objectives**\n- Evaluate **end-to-end task flows** in the PrepChef mobile app (e.g., viewing task list, starting/pausing/completing tasks, handling errors) with real kitchen staff in their actual kitchen environment.[3][5]\n- Validate **touch interactions**: tap accuracy on primary actions, discoverability of key controls, and responsiveness under time pressure and with gloved/wet hands (where applicable).[3][4]\n- Measure **workflow efficiency** impact on kitchen operations: time-on-task, interruptions, and coordination between staff stations when using the app during real prep/service windows.[1][8]\n- Collect both **quantitative usability metrics** (task success rate, time on task, error rate, user satisfaction) and **qualitative insights** (friction points, mental models, workarounds).[2][3][5]\n\n**Dependencies and preconditions**\n- Assume **Task 11** has delivered the single-tap primary action flow and WCAG-compliant touch targets so that this study evaluates the updated interaction model.\n- Coordinate with product/ops to ensure a **stable test build** of PrepChef mobile (feature-flagged as needed) and access to a realistic backend/test environment mirroring production data volumes.[4][9]\n\n**Study design**\n- Define **research goals & hypotheses**:\n  - Hypothesis examples: \"Single-tap primary actions reduce average task completion time by X%\"; \"WCAG-compliant touch targets reduce tap error rate under kitchen conditions.\"[3]\n  - Align metrics with key KPIs: **task success rate, time on task, error rate, user satisfaction (SEQ or SUS subscales)**.[3][2]\n\n- Identify **core task scenarios** (approx. 6–10 per session):\n  - Scan today’s task list, filter by station or priority, and pick the next task.\n  - Start a prep task, mark ingredients ready, update status to done.\n  - Pause and resume a task while handling an interruption.\n  - Resolve a typical error (e.g., missing ingredient, wrong station) using available flows.\n  - Use any feedback/notification patterns that affect the workflow (e.g., toasts, status confirmations).\n\n- **Participant recruitment**:\n  - Recruit 8–15 **representative kitchen staff** (line cooks, prep cooks, expeditors) from 2–3 different locations/shifts to capture varied workflows.[2][5]\n  - Screen for familiarity with smartphones but mix levels of familiarity with PrepChef to understand both onboarding and expert usage.\n\n- **Environment & equipment**:\n  - Conduct sessions **in the live kitchen environment** during realistic, but controlled, service windows (e.g., slower periods) to capture authentic constraints: noise, motion, lighting, gloves, and surface contamination.[1][5][6]\n  - Use the same hardware form factors deployed in production (device models, screen sizes, cases, mounts).\n  - Prepare video recording (with consent) using overhead or shoulder-mounted cameras focused on hands + screen, plus screen recording if possible.[5]\n\n- **Test protocol** (aligned with mobile usability best practices):[3][5][6]\n  - Start with a short **introduction and consent** (purpose, recording, confidentiality, that the app—not the participant—is being tested).\n  - Use a **think-aloud protocol** where practical, but prioritize safety and realistic behavior: prompt verbalization during lulls rather than while handling hot or hazardous items.[2][6]\n  - Present each scenario as a **realistic kitchen task** rather than instructions about UI elements, e.g., \"You just got a new order for 3 salads; use PrepChef to see what you need to prep first.\"[2][3]\n  - Do not coach on specific UI steps; only clarify goals to reveal discoverability and navigation issues.[5][6]\n  - After each task, capture **Single Ease Question (SEQ)** (1–7 scale: \"Overall, how easy or difficult was this task?\") and any immediate comments.[3]\n  - After the full session, administer a short **post-test questionnaire** (e.g., SUS-like items or a brief custom survey) about overall usability, perceived speed, and fit with existing workflow.[3]\n\n**Metrics and instrumentation**\n- **Core quantitative metrics** per task:[3][2]\n  - **Task success rate** (completed without assistance / with minor assistance / failed).\n  - **Time on task** (start to successful completion or abandonment).\n  - **Error rate** (number of observable mis-taps, backtracks, wrong screens, or misinterpretations of status per task).[3]\n  - **Tap precision** proxies: number of repeated taps on the same control, mis-hits on adjacent elements.\n  - **User satisfaction**: SEQ per task and overall post-test ratings.[3]\n\n- **Data capture methods**:\n  - Use a **structured observation sheet** for moderators to log:\n    - Steps taken, deviations from expected flow.\n    - Errors, hesitations, visible confusion.\n    - Environmental factors (noise spikes, rush periods, gloves, wet hands).\n  - Where feasible, instrument the app (feature flag) to log:\n    - Screen transitions for tested flows.\n    - Timestamps for key actions (task opened, primary action tapped, status updated).\n    - Tap events on primary actions and error dialogs (aggregated, non-PII).[4][9]\n\n**Session operations**\n- **Pilot test** with 1–2 kitchen staff (or internal proxy session in a test kitchen) to validate:\n  - Scenario clarity and duration (~30–45 minutes per participant).[5]\n  - Feasibility of note-taking and recording in a busy kitchen.\n\n- **Run study**:\n  - Schedule sessions to avoid peak rush but still include realistic pressure.\n  - Use **two-person teams** where possible: a moderator (guides session) and a note-taker (logs metrics and observations).[5]\n  - Maintain safety: keep observers clear of line-of-fire areas; stop or pause tasks if participants must focus on safety-critical work.\n\n**Analysis and synthesis**\n- **Quantitative analysis**:[2][3][5]\n  - Compute per-task and per-role aggregates: median time on task, success rate, and error rate.\n  - Compare performance across environmental conditions (e.g., gloves vs bare hands, mounted vs handheld) when data volume allows.\n  - Identify tasks with **low success rate (<80%)**, **high error rate**, or **high SEQ difficulty (>4)** as candidates for design changes.\n\n- **Qualitative analysis**:[5]\n  - Transcribe key moments from recordings where users struggle, hesitate, or express confusion.\n  - Thematically code issues (navigation, wording, visibility, feedback latency, physical ergonomics).\n  - Prioritize issues by severity and frequency (e.g., critical, major, minor) and map to impacted flows/components in PrepChef.\n\n- **Output deliverables**:\n  - A **usability findings report** with:\n    - Summary of participants, context, scenarios.\n    - KPI tables/graphs for task success, time, errors, and satisfaction.\n    - Top issues, each with evidence (screenshots, quotes), severity, and recommended design/interaction changes.\n  - A **prioritized backlog list** (user stories or tickets) for UI/UX and engineering teams tied to specific components (e.g., `TaskListScreen`, `TaskDetailScreen`, `PrimaryActionButton`).\n  - A short **stakeholder readout** (slides or Loom-style walkthrough) highlighting key insights for product, design, and engineering.\n\n**Best practices and ethics**\n- Keep participant interaction **non-disruptive** to kitchen throughput: limit per-session time, coordinate with managers, and pause testing during peak surges.[1][6]\n- Ensure **anonymity** in reports: no individual names, only roles and locations.\n- Confirm that test builds and captured data respect privacy and contain no real guest PII.\n- Plan for **iterative cycles**: after implementing high-priority fixes, run a lightweight follow-up usability check on the same core tasks to confirm improvements.[3][5]",
        "testStrategy": "- **Pre-test setup**\n  - Verify the PrepChef test build includes the latest single-tap primary action flows and that analytics/telemetry for key actions is enabled in a non-production environment.\n  - Dry-run the full protocol internally (using at least one real kitchen workstation) to validate timing, recording setup, and that all observation sheets and surveys are clear and unambiguous.\n\n- **Protocol validation during pilot**\n  - Conduct 1–2 pilot sessions with kitchen staff or realistic proxies.\n  - Confirm that:\n    - Each task scenario can be completed within a reasonable time without moderator over-explaining the interface.\n    - Observation templates capture all needed metrics (task success, time, errors, SEQ) without overwhelming the note-taker.\n    - Recording quality (video/screen) is sufficient to reconstruct user actions.\n  - Adjust scenarios, instructions, and data collection sheets based on pilot findings.\n\n- **Execution quality checks**\n  - For each live session, ensure:\n    - Consent is obtained and documented before any recording.\n    - The moderator follows the script and only provides neutral, non-leading prompts.\n    - The note-taker logs start/end times, outcomes, and observed errors for each task.\n  - After 2–3 sessions, perform a quick interim review of notes to check consistency of severity ratings and metric logging, and recalibrate among researchers if needed.\n\n- **Data integrity verification**\n  - Cross-check logged task times from observation sheets against any available in-app telemetry to validate measurement accuracy.\n  - Spot-check a subset of recorded sessions to confirm that coded errors and success/failure labels match what is visible in the video.\n  - Ensure all collected data is stored securely and de-identified before analysis and sharing.\n\n- **Analysis validation**\n  - Recalculate key KPIs (task success rate, mean/median time on task, error rate, SEQ scores) independently by two team members for at least one representative task set to verify that results match.\n  - Review the prioritized issue list in a joint workshop (UX + engineering + product) to confirm severity and feasibility assessments.\n\n- **Outcome verification**\n  - Derive at least 5–10 concrete, actionable recommendations tied to specific screens/components and supported by both qualitative evidence and quantitative metrics.\n  - After implementing top-priority fixes in subsequent tasks, plan a follow-up mini-test (3–5 participants) and confirm that:\n    - Task success rates improve or remain high.\n    - Time on task and error rates are stable or improved.\n    - SEQ scores move towards easier ratings for previously problematic tasks.\n  - Document learnings and update internal usability testing playbook for future PrepChef and Admin/Display app studies.",
        "status": "pending",
        "dependencies": [
          11
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Define research goals, hypotheses, core task scenarios, and test protocol",
            "description": "Establish the research goals, hypotheses, participant criteria, core task scenarios (6-10 per session), and detailed test protocol including think-aloud, SEQ, and post-test questionnaire.",
            "dependencies": [],
            "details": "Align metrics with KPIs like task success rate, time on task, error rate, SUS/SEQ. Define scenarios such as scanning task list, starting/pausing tasks, error resolution. Prepare scripts for introduction, consent, and task presentation as realistic kitchen tasks without UI coaching.",
            "status": "pending",
            "testStrategy": "Review protocol against best practices from usability guidelines; conduct internal dry-run review for clarity and completeness."
          },
          {
            "id": 2,
            "title": "Recruit participants and prepare test environment and equipment",
            "description": "Recruit 8-15 representative kitchen staff from 2-3 locations/shifts, screen for smartphone familiarity, and set up live kitchen environment with production hardware, mounts, video recording setup.",
            "dependencies": [],
            "details": "Coordinate with product/ops for stable test build (feature-flagged) and backend mirroring production. Schedule sessions during slower periods for safety. Prepare consent forms, observation sheets, and recording equipment (overhead/shoulder cameras, screen recording).",
            "status": "pending",
            "testStrategy": null
          },
          {
            "id": 3,
            "title": "Conduct pilot test and execute main usability testing sessions",
            "description": "Run pilot test with 1-2 staff to validate protocol (~30-45 min/session), then execute full sessions using two-person teams (moderator/note-taker), capturing metrics and feedback in live kitchen.",
            "dependencies": [
              1,
              2
            ],
            "details": "Use think-aloud where safe, log quantitative metrics (success rate, time, errors, SEQ) and qualitative notes on observation sheets. Employ app instrumentation for taps/transitions. Ensure non-disruptive operations, safety, and pausing during peaks.",
            "status": "pending",
            "testStrategy": "Verify pilot identifies any scenario issues; during main sessions, cross-check logged metrics against video for accuracy and completeness."
          },
          {
            "id": 4,
            "title": "Collect and organize quantitative and qualitative data",
            "description": "Gather all session data including observation sheets, video recordings, SEQ/post-test scores, app logs; transcribe key moments and compile into structured format for analysis.",
            "dependencies": [
              3
            ],
            "details": "Categorize data by task, role, conditions (e.g., gloves, pressure). Aggregate raw metrics: task success, time on task, error rates, satisfaction. Note environmental factors and workarounds.",
            "status": "pending",
            "testStrategy": null
          },
          {
            "id": 5,
            "title": "Analyze findings and produce deliverables",
            "description": "Perform quantitative analysis (aggregates, comparisons), qualitative thematic coding, prioritize issues; create usability report, prioritized backlog, and stakeholder readout.",
            "dependencies": [
              4
            ],
            "details": "Compute medians for KPIs, identify low-success tasks (<80%), code issues by severity/frequency. Output: report with KPIs/tables/quotes, backlog tickets for components like TaskListScreen, slides/Loom for stakeholders.",
            "status": "pending",
            "testStrategy": "Validate analysis by cross-referencing quantitative outliers with qualitative evidence; review backlog items for traceability to findings."
          }
        ]
      },
      {
        "id": 19,
        "title": "Define Chrome DevTools UX Validation Protocol and Checklists",
        "description": "Develop a standardized Chrome DevTools–based UX validation protocol with detailed checklists for touch targets, performance profiling, accessibility audits, and visual hierarchy, including procedures for testing on real devices and kiosk displays.",
        "details": "## Scope and Goals\n- Create a **repeatable UX validation protocol** using Chrome DevTools and related tooling for:\n  - **Touch target validation** (hit areas, interaction latency) on mobile and kiosk views.\n  - **Performance profiling** focused on UX-centric metrics (LCP, FID/INP, CLS, responsiveness) using the Performance panel and Lighthouse.[7][9]\n  - **Accessibility audits** using DevTools Accessibility pane and Lighthouse, aligned with WCAG 2.1 AA and existing automated suites.[7][9]\n  - **Visual hierarchy assessment** via layout overlays, contrast tools, and device emulation.[7]\n- Document **standard procedures for real devices and kiosk displays**, including configuration of DevTools Remote Debugging and consistent test environments.[7][9]\n\n## Implementation Details\n\n### 1. Protocol Structure & Documentation Format\n- Create a dedicated UX testing guide in the docs repo (e.g. `docs/qa/ux-devtools-protocol.md`) with:\n  - Overview of objectives and when to run each type of UX validation (e.g., before release, after major UI refactors, after token changes).\n  - A consistent structure for each section: **Purpose → Tools → Pre-requisites → Step-by-step procedure → Pass/Fail criteria → Reporting template**.\n- Provide printable / copy-pastable **checklist tables** for each category (touch targets, performance, accessibility, visual hierarchy).\n\n### 2. Touch Target Validation Checklist (Mobile & Kiosk)\n- Base checklist on common UX guidelines (44×44 px or equivalent logical size, spacing, and error prevention) and integrate with DevTools capabilities.[7][9]\n- Define **pre-requisites**:\n  - Build to test environment with latest design tokens and component updates (depends on @codemachine/ui token standardization work from Task 16).\n  - Known viewport presets (e.g., 360×640 for phone, actual kiosk resolution from Task 14 work).\n- Define **DevTools-based procedure**:\n  - Use **Device Mode** in Chrome DevTools to emulate target devices, DPR, and throttling; save presets for PrepChef mobile and Display kiosk.[7]\n  - Use **Inspect Element** to verify rendered tap target sizes and spacing; document recommended minimum CSS sizes and how to measure with the DevTools box model and rulers.[7]\n  - Use the **Performance panel** to record tap interactions and check input delay (look for long tasks >50 ms after input events).[9]\n  - For kiosk: combine with typography and density constraints defined in Task 14 (e.g., ensure large tap regions for large, distant buttons).\n- Create a **Touch Target Checklist**, e.g.:\n  - All primary actions meet minimum size threshold (specify px and logical size). \n  - Minimum spacing between adjacent tap targets.\n  - No critical control is within N px of screen edges used for OS gestures.\n  - Input delay on primary flows < specified threshold (e.g., <100 ms on average traces).\n\n### 3. Performance Profiling Protocol\n- Base protocol on **DevTools Performance panel** and **Lighthouse** best practices.[7][9]\n- **Pre-requisites**:\n  - Clear cache or use an Incognito window.\n  - Configure consistent network/CPU throttling profiles (e.g., Fast 3G / 4× CPU slowdown) and save them as shared presets.[9]\n- **Step-by-step DevTools Performance workflow**:[9]\n  - Open Performance panel, enable screenshots and Web Vitals if available.\n  - Start a recording, perform a defined UX flow (e.g., open dashboard, scroll list, trigger bulk action, kiosk update), stop recording.\n  - Identify **LCP**, **CLS**, long tasks, and main-thread blocking time in the summary pane.[9]\n  - Annotate trace screenshots with timestamps for critical UX moments (screen appears, controls become interactive).\n- **Lighthouse procedure**:\n  - Run Lighthouse from DevTools for both mobile and desktop modes, capture Performance and Accessibility scores.[7]\n  - Export Lighthouse JSON/HTML reports and link them in the test report template.\n- Create a **Performance Checklist**, including:\n  - LCP < defined threshold on key screens.\n  - Minimal layout shift on load and during updates.\n  - No long tasks above agreed budget on core flows.\n  - Stable FPS for scrolling and kiosk auto-updates (no visible jank).\n\n### 4. Accessibility Audit Protocol (DevTools-focused)\n- Align this manual DevTools protocol with the **automated axe/Playwright suite from Task 17** and clarify **when to use which**.\n- **DevTools Accessibility pane workflow**:[7]\n  - Use the **Elements → Accessibility** tree to inspect role, name, and state of key controls.\n  - Verify focus order by using keyboard navigation and observing the active element in DevTools.\n- **Lighthouse Accessibility**:\n  - Run Lighthouse Accessibility audits for target pages and capture issues list.[7]\n  - Map Lighthouse findings to WCAG 2.1 AA criteria and to automated Playwright/axe tests from Task 17.\n- Create an **Accessibility Checklist**, e.g.:\n  - All interactive elements have correct roles, labels, and focus indicators.\n  - No contrast violations according to Lighthouse; for kiosk, cross-check with high-contrast mode from Task 14.\n  - Keyboard-only users can complete key flows (confirmed via DevTools inspection and manual keyboard walkthrough).\n\n### 5. Visual Hierarchy Assessment Protocol\n- Describe how to use DevTools to assess **visual hierarchy**:\n  - Device Mode for mobile vs kiosk layouts and zoomed-out views for distance perception.[7]\n  - Element highlighting and layout tools (such as box model overlays and CSS Grid/Flex overlays) to check spacing and alignment.[7]\n  - Emulation of different color schemes/high-contrast modes and simulated color vision deficiencies (where supported) to assess priority and contrast.[7]\n- Define **heuristics** for hierarchy:\n  - Clear visual priority for primary KPIs and actions (ties to Task 15 dashboard and Task 14 kiosk redesign).\n  - Consistent use of type scale, color, and spacing from standardized design tokens (Task 16).\n- Provide a **Visual Hierarchy Checklist**, including:\n  - Primary KPIs/buttons appear above the fold and are visually dominant.\n  - Secondary information is visually subordinate but still legible.\n  - No conflicting cues (e.g., secondary actions styled more prominently than primary).\n\n### 6. Real Device and Kiosk Testing Procedures\n- Document how to connect **real Android/iOS devices and kiosk hardware** to DevTools for remote debugging and performance profiling:[7]\n  - Android: enable Developer Options, USB debugging, connect via `chrome://inspect`.\n  - Kiosk: connect to the kiosk’s browser session via remote debugging port.\n- Define **environment setup**:\n  - Required Chrome version range and flags.\n  - Standard display settings for kiosk runs (resolution, scaling, brightness, distance from viewer) referencing Task 14 test setup.\n- Provide step-by-step **real-device protocol**:\n  - Connect device, open target app or PWA, attach DevTools.\n  - Run the same touch, performance, accessibility and hierarchy checklists as in emulation, noting any discrepancies.\n  - Capture screenshots and video of real usage where relevant.\n\n### 7. Integration with Existing Testing & Reporting\n- Define how this UX protocol complements:\n  - **Task 17** automated Playwright/axe accessibility and performance tests.\n  - **Task 18** in-kitchen usability sessions (DevTools traces can be recorded during real sessions for deeper analysis).\n- Create a **standard report template** (e.g., `docs/qa/templates/ux-devtools-report.md`) with sections:\n  - Context (build version, date, tester, device information).\n  - Checklists with pass/fail and notes.\n  - Links to DevTools performance recordings (saved JSON traces), Lighthouse reports, screenshots.\n  - Prioritized issues with severity and suggested owners (@ui-ux, @business-logic, etc.).\n\n### 8. Knowledge Sharing\n- Add short **how-to snippets** and annotated screenshots to help new team members follow the protocol.\n- Schedule an internal walkthrough to present the protocol to QA, UX, and engineering, and capture adjustments based on feedback.\n\n## Current Best Practices & Technologies Reflected\n- Use of **Chrome DevTools Performance panel, Lighthouse, Device Mode, Accessibility panel** as primary tools for diagnostic UX testing.[7][9]\n- Emphasis on **LCP, CLS, long tasks, and interactivity** as key performance metrics when evaluating UX responsiveness.[9]\n- Integration with **Chrome DevTools Protocol–based automation** (Puppeteer, etc.) as future extensions, but keeping this task primarily documentation/protocol-focused.[1][4][6]\n",
        "testStrategy": "## Overall Validation\n- Verify that the **UX DevTools protocol document** and **checklists** exist, are complete, and accessible in the agreed documentation location (e.g., `docs/qa/ux-devtools-protocol.md` plus templates).\n- Confirm that each checklist (touch targets, performance, accessibility, visual hierarchy) includes: tools, pre-requisites, ordered steps, explicit pass/fail thresholds, and reporting fields.\n\n## Protocol Dry Runs\n\n### 1. Touch Target Validation\n- Using a recent build of PrepChef mobile and the Display kiosk:\n  - In Chrome DevTools, enable Device Mode with the documented viewport presets and follow the touch target checklist step-by-step.\n  - Confirm a tester can:\n    - Measure tap target sizes and spacing using Inspect and box model overlays.\n    - Record a Performance trace around a tap and locate the associated input events and long tasks.\n  - Ensure the checklist yields actionable results (at least one example issue can be recorded if present) and that fields are clear.\n\n### 2. Performance Profiling\n- For at least one key flow in Admin CRM dashboard (Task 15) and one in Display kiosk:\n  - Apply the documented network/CPU throttling settings.\n  - Record a Performance trace following the protocol.\n  - Verify the tester can reliably identify LCP, CLS and long tasks and evaluate them against the documented thresholds.\n  - Run Lighthouse from DevTools in both mobile and desktop modes, confirm the protocol’s instructions match the actual UI.\n\n### 3. Accessibility Audits\n- On a target screen in Admin CRM and Display kiosk:\n  - Follow the Accessibility protocol to inspect roles, names and focus order via DevTools.\n  - Run Lighthouse Accessibility and confirm the steps and screenshots in the doc align with the experienced workflow.\n  - Cross-check a subset of issues discovered here against results from the Playwright/axe suite (Task 17) to ensure conceptual alignment.\n\n### 4. Visual Hierarchy Assessment\n- On the Admin CRM dashboard and the main kiosk screen:\n  - Follow the Visual Hierarchy checklist to evaluate priority of KPIs/actions and use DevTools overlays as described.\n  - Confirm that two independent reviewers using the same checklist arrive at similar qualitative conclusions (sanity-check clarity of criteria).\n\n### 5. Real Device and Kiosk Procedures\n- Connect an Android test device via USB and:\n  - Attach Chrome DevTools using `chrome://inspect` following the documented steps.\n  - Perform at least one short performance trace and one accessibility inspection, ensuring the instructions are accurate and complete.\n- On a kiosk setup (or a representative large external display):\n  - Attach DevTools via remote debugging.\n  - Follow the kiosk-specific parts of the protocol, including distance and readability notes from Task 14.\n\n### 6. Documentation Quality and Maintainability\n- Have at least one QA engineer and one UX designer follow the protocol **without prior explanation** and:\n  - Complete all four checklists on a sample screen.\n  - Provide feedback on missing steps, ambiguities, or incorrect references; update the document accordingly.\n- Confirm all referenced artifacts (Lighthouse exports, performance trace examples, report template) are linked or clearly located and version-controlled.\n",
        "status": "pending",
        "dependencies": [
          14,
          16,
          17,
          18
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Define overall UX DevTools protocol structure and documentation artifacts",
            "description": "Design the high-level structure, sections, and file locations for the Chrome DevTools UX validation protocol and associated templates.",
            "dependencies": [],
            "details": "• Create the main protocol document skeleton (e.g., docs/qa/ux-devtools-protocol.md) including sections for touch targets, performance profiling, accessibility audits, visual hierarchy, and real-device/kiosk procedures.\n• Standardize section format as Purpose → Tools → Pre-requisites → Step-by-step procedure → Pass/Fail criteria → Reporting template.\n• Specify naming/location for supporting artifacts (e.g., docs/qa/templates/ux-devtools-report.md, per-checklist subsections or tables within the main doc).\n• Align terminology and scope with Tasks 14, 16, 17, and 18 so cross-references can be added cleanly in later subtasks.\n• Get quick sign-off from UX/QA on the outline before populating detailed content.",
            "status": "pending",
            "testStrategy": "Open the new documentation files, verify required sections and headings exist and follow the agreed structure; confirm links between main protocol and template locations work."
          },
          {
            "id": 2,
            "title": "Author touch target validation checklist and procedures (mobile & kiosk)",
            "description": "Create a DevTools-based touch target validation checklist and step-by-step workflow for mobile and kiosk experiences.",
            "dependencies": [
              1
            ],
            "details": "• Document pre-requisites: test build availability, design tokens and components from Task 16, and viewport presets (phone and kiosk resolutions referencing Task 14 outputs).\n• Describe how to configure and save Device Mode presets for key devices, including DPR, throttling, and kiosk resolutions.\n• Define a measurement procedure using Inspect Element, box model, rulers, and overlays to verify tap target size and spacing; include recommended minimum CSS/px and logical size values.\n• Specify how to capture and review interaction latency using the Performance panel (recording taps, checking long tasks >50 ms after input events).\n• Produce a printable/copy-paste checklist table covering size thresholds, spacing, edge proximity, and latency budgets for core flows on both mobile and kiosk.\n• Add guidance for interpreting failures and linking issues back to token or component changes from Task 16.",
            "status": "pending",
            "testStrategy": "Run the checklist on at least one mobile view and one kiosk layout, verify each step is clear and feasible, and confirm that measurements and latency checks can be reproduced by another tester following only the written protocol."
          },
          {
            "id": 3,
            "title": "Define performance profiling and Lighthouse-based UX checks",
            "description": "Specify a repeatable DevTools Performance panel and Lighthouse workflow with a UX-focused performance checklist.",
            "dependencies": [
              1
            ],
            "details": "• Document environment pre-requisites: using Incognito or cleared cache, standardized network/CPU throttling profiles, and how to save and share these as presets.\n• Write a step-by-step procedure for capturing Performance traces for representative UX flows (navigation, scrolling, kiosk updates), including enabling screenshots and Web Vitals.\n• Describe how to identify and record LCP, CLS, long tasks, and main-thread blocking time from traces, and how to annotate critical UX timestamps.\n• Define the Lighthouse run procedure in DevTools for mobile and desktop modes, including which categories to select and how to export/store reports.\n• Create a performance checklist table with concrete thresholds for LCP, acceptable layout shift, long-task budgets, and scroll/FPS expectations for both standard and kiosk scenarios.\n• Note how this protocol complements existing automated performance checks (e.g., from Task 17) without duplicating them.",
            "status": "pending",
            "testStrategy": "Execute the documented workflow on at least one key user flow, verify that another tester can obtain similar metrics and Lighthouse scores, and confirm that all checklist items can be filled using only data from the described tools."
          },
          {
            "id": 4,
            "title": "Create accessibility and visual hierarchy DevTools audit checklists",
            "description": "Develop DevTools-focused procedures and checklists for accessibility audits and visual hierarchy assessment, integrated with existing automation and design tokens.",
            "dependencies": [
              1
            ],
            "details": "• For accessibility, document a workflow using the DevTools Accessibility pane and keyboard navigation to inspect roles, names, states, focus order, and focus indicators on key flows.\n• Specify how and when to run Lighthouse Accessibility audits, and how to map their findings to WCAG 2.1 AA and to the automated Playwright/axe suite from Task 17.\n• Build an accessibility checklist table covering roles/labels, focus management, keyboard-only completion of flows, and contrast requirements (with kiosk-specific notes referencing Task 14 high-contrast setups).\n• For visual hierarchy, outline how to use Device Mode, element highlighting, layout overlays, and color/emulation tools to evaluate spacing, alignment, prominence of primary actions/KPIs, and consistency with design tokens from Task 16.\n• Create a visual hierarchy checklist table capturing hierarchy heuristics (primary vs secondary information, above-the-fold presence, avoidance of misleading visual cues).\n• Include brief notes on interpreting common issues and how to feed them back to UX and design-token owners.",
            "status": "pending",
            "testStrategy": "Apply the accessibility and visual hierarchy checklists to at least one dashboard and one kiosk screen, verify all items can be evaluated using the documented DevTools steps, and confirm alignment with existing automated accessibility reports."
          },
          {
            "id": 5,
            "title": "Document real-device/kiosk procedures and integrate reporting template",
            "description": "Define remote debugging procedures for real devices and kiosks and finalize the unified UX DevTools reporting workflow.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "• Document step-by-step instructions to connect Android devices (via Developer Options and chrome://inspect) and kiosk hardware (via remote debugging ports) to DevTools.\n• Specify standard environment settings for kiosks (Chrome versions, resolution, scaling, brightness, and viewing distance) referencing Task 14’s test setup.\n• Describe how to re-run the touch target, performance, accessibility, and visual hierarchy checklists on physical devices, including how to note differences from emulation.\n• Define expectations for capturing and storing screenshots, videos, Performance traces, and Lighthouse reports during real-device sessions.\n• Create or complete the standard report template (e.g., docs/qa/templates/ux-devtools-report.md) with sections for context, checklist results, attached artifacts, and prioritized issues/owners.\n• Add guidance on how this protocol feeds into Task 18 in-kitchen usability sessions and how QA/UX should share findings with engineering.",
            "status": "pending",
            "testStrategy": "Dry-run the full protocol on at least one real mobile device and one kiosk setup, fill out the report template end-to-end, and verify that another team member can reproduce the setup and reporting using only the documented steps."
          }
        ]
      },
      {
        "id": 20,
        "title": "Enhance Display Kiosk App for Distant Readability with Typography Tokens, High-Contrast Theme, and Reduced-Density Layout",
        "description": "Implement kiosk-specific typography tokens, high-contrast theme variant with runtime toggle, KioskLayout component, and update key Display app components for 6–10ft readability while ensuring WCAG 2.1 AA compliance and 60fps performance.",
        "details": "Owner: @ui-ux. Work in parallel with Task 12 (PrepChef toasts) and coordinate shared token updates/accessibility patterns with UI team and Task 13.1.\n\n**Core Implementation (follow subtasks order):**\n1. **Kiosk Tokens**: Add to `libs/ui/src/theme/tokens.css`:\n   ```css\n   :root {\n     --kioskHeading: 32px / 40lh;\n     --kioskSubheading: 24px / 32lh;\n     --kioskBody: 20px / 28lh;\n     --kioskSpacingLarge: 3rem;\n   }\n   ```\n   Export from tokens module: `export const kioskTokens = { kioskHeading: 'var(--kioskHeading)', ... };`\n\n2. **KioskLayout Component**: Create `libs/ui/src/components/KioskLayout.tsx`:\n   ```tsx\n   export const KioskLayout = ({ children }: { children: React.ReactNode }) => (\n     <div className=\"kiosk-layout\" style={{ '--kiosk-spacing': 'var(--kioskSpacingLarge)' }}>\n       {children}\n     </div>\n   );\n   ```\n   Use CSS Grid/Flexbox for reduced density, 48px+ touch targets.\n\n3. **Component Updates**:\n   - `apps/display/components/SummaryGrid.tsx`: Replace headings/body with `kioskHeading`, `kioskBody`; use `kioskSpacingLarge`.\n   - `apps/display/components/UrgentTicker.tsx`: Apply `kioskSubheading` + increased line-height/spacing.\n\n4. **High-Contrast Theme**: Add `libs/ui/src/theme/highContrast.css` with WCAG AA pairs (contrast ≥4.5:1):\n   ```css\n   .theme-kiosk-high-contrast {\n     --color-bg: #000;\n     --color-text: #fff;\n     /* Full palette */\n   }\n   ```\n   Implement runtime toggle via existing ThemeProvider/context + feature flag `display.kiosk_high_contrast`.\n\n5. **Toggle UI**: Add to `apps/display/components/Header.tsx`:\n   ```tsx\n   const [highContrast, setHighContrast] = useLocalStorage('kiosk-high-contrast', false);\n   <Toggle aria-label=\"Toggle high contrast\" checked={highContrast} onChange={() => { setHighContrast(!highContrast); }} />\n   ```\n   Persist via localStorage, gate behind feature flag.\n\n6. **Performance/Accessibility**:\n   - Minimal CSS transitions only.\n   - ARIA landmarks on KioskLayout.\n   - Coordinate Task 13 tokens/ARIA.\n\n**Deliverables**:\n- Storybook stories for KioskLayout + high-contrast variants.\n- Visual regression screenshots (default vs high-contrast).\n- Unit tests: tokens export, KioskLayout.\n- Axe-core tests: contrast, keyboard nav.\n- Performance checklist: Chrome DevTools trace ~60fps.",
        "testStrategy": "**Manual Verification**:\n- Distance test: Verify readability at 6-10ft on kiosk display (order #, status distinguishable).\n- Toggle high-contrast: Confirm runtime switch, localStorage persistence, feature flag gating.\n- Layout: Measure touch targets ≥48px, spacing via DevTools.\n\n**Automated Tests**:\n- Unit: `kioskTokens` exports correct values; KioskLayout renders w/ proper CSS vars.\n- Integration: SummaryGrid/UrgentTicker adopt tokens (snapshot test).\n- Accessibility: Axe-core Playwright: 0 WCAG 2.1 AA violations (contrast, keyboard, landmarks).\n- Performance: Chrome DevTools trace under simulated load → LCP<2.5s, 60fps, DOM nodes <500.\n\n**Visual/Regression**:\n- Storybook: KioskLayout default/high-contrast variants.\n- Screenshots: Compare before/after typography + density reduction.\n\n**Cross-browser**: Chrome/Edge kiosk mode, touch simulation.",
        "status": "pending",
        "dependencies": [
          13,
          16
        ],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-12-17T21:43:59.191Z",
      "updated": "2025-12-18T08:19:01.485Z",
      "description": "Tasks for master context"
    }
  }
}