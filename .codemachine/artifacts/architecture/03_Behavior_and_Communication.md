<!-- anchor: 3-0-proposed-architecture-behavioral-view -->
## 3. Proposed Architecture (Behavioral View)

*   **3.7. API Design & Communication:**
    *   **API Style:**
        - RESTful JSON Next.js App Router route handlers remain the canonical entrypoints for staff, kiosk, and admin clients.
          They expose deterministic paths such as `/api/tasks`, `/api/tasks/:id/claim`, `/api/tasks/combine`, `/api/events`, and `/api/recipes`.
        - Every handler keeps business rules in shared libraries so that `apps/prepchef`, `apps/caterking`, `apps/admin-crm`, and `apps/display` reuse the same contracts.
          The handlers only orchestrate dependency injection, schema validation, and response shaping before deferring to Supabase RPCs.
        - Edge-compatible routes deliver low-latency reads for the task dashboard, while Node runtimes serve media-signing or other stateful logic.
          This split follows the blueprint directive to keep server components pure and to isolate heavier compute workload behind Supabase functions.
        - Supabase Auth JWTs accompany each request, and middleware lifts company_id plus role claims into handler context.
          RLS-safe queries inside `libs/supabase` apply these claims automatically, preventing accidental cross-tenant leakage.
        - React Server Components fetch from the same REST endpoints during streaming renders, using fetch caches tuned per route.
          Subsequent client-side React Query calls hit identical URLs to guarantee consistent caching keys and optimistic updates.
        - Responses follow JSON:API-inspired envelopes with `data`, `meta`, and `schema_version` fields, ensuring clients can detect contract shifts.
          Errors standardize on `error.code`, `error.message`, and `error.remediation`, enabling kiosk displays to show actionable notices.
        - Mutations require idempotency headers (`X-Idempotency-Key`) generated by `libs/shared/tasks`, satisfying the resilience requirement for double taps.
          Next.js route handlers persist keys to Supabase via helper tables so repeated submissions short-circuit with 200 responses referencing the original state.
        - Each API call logs structured telemetry (trace_id, actor_id, company_id, feature_flag_state) before returning.
          Observability hooks stream logs to Logflare-compatible sinks, feeding Ops dashboards defined in the blueprint.
        - Feature flag evaluations run server-side using the Flagsmith wrapper so responses conditionally include heuristic suggestions or experimental fields.
          The `feature_exposures` array in response metadata documents which toggles impacted the payload, satisfying audit directives.
        - Request validation uses Zod schemas exported from `libs/shared`, eliminating duplicated DTO parsing logic.
          Invalid payloads never reach Supabase, protecting RLS policies from unnecessary invocations.
        - The API layer enforces pagination for any list exceeding 50 rows, aligning with the performance budget for mobile clients.
          Cursor metadata includes `next_cursor` and `prev_cursor`, making infinite scroll in `apps/prepchef` deterministic.
        - Task-combine endpoints accept structured normalization metadata rather than free-form text to keep heuristics tunable.
          This design allows Supabase functions to reproduce similarity decisions for audit logs or rollback scenarios.
        - Bulk operations (assignments, recipe edits) expose sub-resources like `/api/tasks/bulk-assign` that wrap RPC calls with transaction guarantees.
          Managers in `apps/admin-crm` thus trigger a single HTTP call even when dragging dozens of tasks across swimlanes.
        - Media upload APIs (`/api/media/sign`) only emit signed URLs plus policy tokens; uploads go directly to Supabase Storage to keep API servers stateless.
          Callback Supabase Functions update Postgres, and API handlers simply forward status to clients.
        - Undo flows rely on `/api/tasks/:id/undo` which checks unexpired undo tokens generated at claim/complete time.
          The handler returns both reverted task payloads and updated audit log entries so `apps/display` stays in sync.
        - Wall-display summary data flows through `/api/display/summary`, a GET endpoint that reads from materialized snapshot tables.
          The API ensures kiosk devices do not subscribe to full task streams yet still honor real-time freshness budgets.
        - Recipe viewer APIs provide chunked streaming responses using `ReadableStream` when instructions exceed defined thresholds.
          Staff devices thus begin rendering headings and wrappers before the entire JSON finishes transferring, protecting UX in busy kitchens.
        - Version negotiation occurs through the `schema_version` attribute, and incompatible clients receive `426 Upgrade Required` with remediation links.
          This prevents outdated kiosk builds from sending writes that Supabase would reject due to new columns.
        - Webhook-style integrations remain disabled for MVP, yet API payloads already include `event_type` metadata so future connectors can subscribe via Doppler-managed secrets.
          Behavior flows remain deterministic even when third parties appear later because mutation order is preserved through RPC transaction logs.
        - Request throttling applies per company via middleware that counts operations in Supabase-backed limiter tables.
          Rate limit headers let managers understand when kiosk polling should be reduced or when automation is saturating shared budgets.
        - Error responses map to actionable categories: `validation`, `authorization`, `conflict`, `dependency`, `system`.
          UI clients translate these categories into toast variants defined inside `libs/ui`, maintaining consistent messaging across apps.
        - Sideloading of related entities (e.g., tasks plus recipe snippet) uses `include` query params but caps expansion count, guarding payload sizes.
          Managers can still see necessary context without overwhelming mobile bandwidth.
        - Real-time updates never bypass the REST APIs; even when Supabase Realtime pushes a change, clients reconcile via React Query invalidation hitting GET endpoints.
          This ensures eventual consistency and avoids UI divergence when background jobs mutate tasks.
        - API contracts embed `undo_available_until` timestamps so each client enforces the same limit without relying solely on timers.
          Both staff and managers observe identical undo opportunities, preventing race conditions across surfaces.
        - Security headers (`Strict-Transport-Security`, `Content-Security-Policy`, `Permissions-Policy`) apply uniformly because Next.js responds centrally.
          Media-specific endpoints add `Cross-Origin-Resource-Policy` to prevent untrusted reuse of signed assets.
        - Supabase Edge Functions power compute-heavy heuristics, yet API handlers proxy invocation via typed clients to maintain consistent HTTP semantics.
          Clients simply await REST responses while the server orchestrates asynchronous functions and finalizes transactions upon completion.
        - Autoscaling is simplified because stateless APIs allow Vercel to spin up additional Edge locations without storing session data.
          Company_id context always travels with JWT claims, so new instances immediately enforce the same access constraints.
        - Audit logging is triggered within the RPC layers, but API responses include `audit_reference_id` for correlation.
          Managers can cross-link UI actions with database entries when investigating anomalies.
        - Task comments and metadata use `PATCH /api/tasks/:id` with field-level whitelists to avoid accidental overwrites.
          The API rejects unknown JSON keys, forcing clients to upgrade intentionally when new properties appear.
        - Localization remains future-facing, yet API responses already provide `display_name_localized` arrays for key strings so multi-language expansions are trivial later.
          This approach keeps the API neutral to formatting and pushes presentation decisions into UI layers.
        - WebSockets beyond Supabase Realtime are prohibited per blueprint, so APIs avoid long-lived HTTP connections.
          Polling fallback uses `Cache-Control: no-store` to force fresh fetches whenever realtime is unavailable.
        - Response compression relies on Vercel-managed Brotli/Gzip, and handlers flag large JSON (recipes, methods) with streaming hints.
          Combined with pagination, this ensures SLO compliance under multi-event loads.
        - All endpoints document their OpenAPI specs stored in the repo, and Postman collections reference those documents for QA.
          Behavior architects rely on these specs to reason about concurrency, ensuring scenario coverage across staff and manager flows.
        - Task aggregation suggestions are exposed via `/api/tasks/suggestions` which returns candidate groups plus heuristics metadata.
          Because the same API handles acceptance, clients never manipulate heuristics locally, preserving determinism.
        - Staff presence heartbeats call `/api/presence` every 30 seconds with minimal payloads, enabling Ops dashboards to monitor kiosk health without overloading networks.
          The API short-circuits if the timestamp matches the server's stored heartbeat, preventing redundant writes.
        - Permissions are double enforced: middleware checks route-level ACL derived from `libs/shared/access`, and Supabase RLS guards database rows.
          As a result, even if a client bypasses UI gating, API calls still fail with `403` and emit audit logs.
        - Response caches integrate with React Query `staleTime` hints returned via `meta.cache.hints`.
          Clients share these hints so staff dashboards know when to prefetch or wait for realtime invalidations.
        - Supabase connection pooling is abstracted by `libs/supabase`, preventing Next.js routes from creating redundant clients on each invocation.
          That wrapper reuses server-side connections and exposes instrumentation hooks for per-request tracing.
        - API responses include `links.self` and `links.poll` so kiosk watchers can easily rehydrate after downtime.
          This matches the multi-channel requirement where `/display` surfaces need stable, bookmarkable URIs.
        - All JSON fields follow snake_case to align with Supabase column names, but UI components convert them to camelCase via adapters.
          This prevents repeated serialization transforms and keeps DTOs symmetrical with database migrations.
    *   **Communication Patterns:**
        - Synchronous task operations flow from `apps/prepchef` UI gestures through shared hooks into Next.js API routes.
          The API routes call `libs/supabase` helpers that wrap Supabase RPCs (`claim_task`, `complete_task`) inside transactions before returning JSON responses.
          React Query updates the local store optimistically and listens for Supabase Realtime confirmations on `company:{company_id}:tasks`.
        - Managers in `apps/admin-crm` trigger manual assignments via drag-and-drop, producing batched requests to `/api/tasks/bulk-assign`.
          The API shards payloads into deterministic sequences so Supabase transaction logs remain ordered, ensuring kiosk displays reflect identical steps.
          Supabase Realtime broadcasts propagate to `apps/display` and `apps/caterking`, which fold them into aggregated counters without hitting the API again.
        - Task combination suggestions originate from background Supabase functions invoked through `/api/tasks/suggestions`.
          After heuristics compute candidate groups, they persist metadata inside `supabase/sql` tables and push events via `company:{company_id}:task_suggestions`.
          Staff or managers respond synchronously through `/api/tasks/combine`, and the approval event cascades to undo services plus audit logs.
        - Recipe drawer access mixes synchronous fetches and cached context.
          `apps/prepchef` requests `/api/recipes/:id?version=current` to retrieve structured JSON, while `libs/supabase` simultaneously opens media metadata and signed URLs.
          Supabase Storage events notify the Media Processing pipeline, and `apps/prepchef` refreshes once `Supabase Realtime` emits a ready status.
        - Media uploads from `apps/admin-crm` call `/api/media/sign` to obtain signed PUT URLs.
          The client streams bytes directly to Supabase Storage; upon completion, a Supabase Function updates Postgres and triggers `company:{company_id}:media`.
          `apps/prepchef` consumes these events to update method drawers without a full page reload.
        - Undo workflows rely on asynchronous messaging plus synchronous verification.
          When a staff user taps undo, the app sends `/api/tasks/:id/undo`, which checks the stored `undo_token` and writes reversal entries to `supabase/sql`.
          Supabase Realtime emits both the reverted task and the expired token event so other devices prevent duplicate undo attempts.
        - Presence tracking loops every 30 seconds from each client via `/api/presence`.
          The API writes the heartbeat timestamp and pushes a condensed event onto `company:{company_id}:presence`.
          `apps/display` listens for absence of updates and surfaces warnings when a device deadline is exceeded.
        - Feature flag propagation travels through middleware that evaluates Flagsmith and injects results into React context responses.
          Each UI includes the evaluated flag map in its local state, yet mutations still pass the server-verified values to ensure deterministic behavior.
          Observability events carry both user actions and active flags, enabling Ops to correlate outcomes.
        - Real-time dashboards degrade gracefully by switching to short polling sequences.
          When `Supabase Realtime` emits a disconnection notice, `apps/prepchef` toggles a banner and begins hitting `/api/tasks?since=<timestamp>` every 10 seconds.
          Once realtime reconnects, the poller stops and the channel resumes delivering deltas.
        - The kiosk display consumes aggregated summaries using a hybrid approach.
          `apps/display` polls `/api/display/summary` for baseline payloads, then listens to `company:{company_id}:display_snapshots` for immediate updates when managers reconfigure filters.
          This prevents expensive fan-out of every task mutation while keeping the wall board within the 15-second freshness SLA.
        - Training content flows from `apps/admin-crm` uploads into the Training Content Service, which stores metadata and triggers notifications.
          Staff devices subscribe to `company:{company_id}:methods` and fetch `/api/methods/:id` only when the user opens a drawer, reducing idle bandwidth.
          Sequence diagrams highlight the interplay between asynchronous content readiness and on-demand fetches.
        - Audit logging occurs out-of-band yet within the same transaction boundary.
          RPCs append audit rows, and a Supabase trigger forwards condensed copies to the Observability Stack via webhook.
          Clients never see this traffic, yet analytics surfaces rely on it for compliance.
        - The Notification & Undo Service coordinates ephemeral toasts.
          After a mutation, Next.js responses include `toast_directives` describing message text, severity, and TTL.
          Realtime skip-level events can also instruct clients to dismiss stale toast IDs, ensuring synchronization across multiple logged-in devices.
        - Event creation originates from `apps/admin-crm` or `apps/caterking` and travels through `/api/events`.
          Once Supabase stores the event, a function seeds default tasks, emits `company:{company_id}:events`, and triggers React Query invalidations within affected clients.
          Staff dashboards adjust filter sections dynamically without human intervention.
        - Staff schedule data sync uses scheduled jobs.
          When managers finalize staffing in `apps/admin-crm`, the API writes schedule entries and pings `company:{company_id}:schedules`.
          `apps/prepchef` consumes these updates to highlight tasks assigned to currently clocked-in staff only.
        - Station filtering requires concurrency between route handlers and realtime.
          `/api/tasks?station=prep` returns curated lists, while `Supabase Realtime` events carry `station_id` metadata so clients know if they should insert or ignore a change.
          This prevents pastry users from seeing hot line work in chaotic periods.
        - Method playback events pipeline: staff selects a method in `apps/prepchef`, the app fetches JSON plus signed media, and once playback begins it emits `/api/methods/:id/view`.
          The API logs the view count, updates `Supabase Realtime` for training analytics, and Ops dashboards aggregate compliance metrics.
        - Display snapshot capturing is orchestrated by Next.js cron routes hitting `/api/display/snapshot`.
          They compute aggregated payloads via `libs/shared/display`, store them in `DisplaySnapshot` tables, and publish to Realtime for offline diagnostics.
          Managers can scrub historical states without overloading clients.
        - Combined group rollbacks rely on asynchronous orchestration.
          When a manager dissolves a combined group, `/api/tasks/combine/rollback` instructs Supabase functions to recompute original quantities and statuses.
          Realtime emits a `group_rolled_back` event that `apps/prepchef` interprets to reinsert tasks in proper order while `apps/display` updates counters.
        - Observability alerts originate from log processors that detect anomalies (e.g., repeated conflicts).
          When thresholds breach, the system writes a notification to Supabase and emits `company:{company_id}:alerts`.
          `apps/admin-crm` surfaces these alerts via banner components, enabling human intervention.
        - Recipe version control leverages synchronous updates with asynchronous propagation.
          `/api/recipes/:id` updates version metadata immediately, and Supabase triggers compute diffs for analytics before broadcasting via `company:{company_id}:recipes`.
          Clients compare `version` numbers and prompt users to refresh instructions when stale.
        - Authentication handshake occurs via Supabase Auth, yet Next.js middleware attaches session context to every request.
          Clients never transmit custom tokens; they rely on Supabase session objects that the API reads through `libs/supabase`.
          Logouts propagate through session presence events, causing all apps to drop caches promptly.
        - Real-time station occupancy uses presence data plus event assignments.
          API routes compute occupancy ratios and push them to `company:{company_id}:station_metrics`, and kiosk displays update gauge cards asynchronously.
          Managers rely on this data to limit new claims when a station saturates.
        - Supabase cron jobs execute nightly cleanup for expired undo tokens and stale presence rows.
          Completion events fire through `company:{company_id}:maintenance`, letting `apps/admin-crm` show maintenance notifications without manual refreshes.
        - Conflict resolution for simultaneous claims uses sequential RPC semantics plus realtime arbitration.
          If Supabase returns a `conflict` error, the API responds with `409` and the UI opens a toast while waiting for realtime to deliver the winning state.
          Managers can still reassign manually because `/api/tasks/:id/claim` always returns the current server-assigned user_id.
        - Heuristic experiment gating uses a combination of feature flags and metadata topics.
          When a beta flag is on, `/api/tasks/suggestions` adds `experiment_id`, and Supabase pushes matching `experiment_id` in realtime payloads.
          Analytics correlates acceptance rates across tenants without diverging contract structures.
        - Wall displays degrade to cached summaries when Realtime fails while the API is unreachable.
          `apps/display` reads the latest `DisplaySnapshot` payload from IndexedDB and shows a banner referencing snapshot timestamp.
          Once connectivity resumes, a `snapshot_restored` event clears the fallback state for all viewers simultaneously.
        - Recipe streaming interactions maintain ordering via event-sourced metadata.
          Clients acknowledge each chunk, and server-sent metadata ensures Supabase storage logs know which assets were delivered successfully.
          Retries request missing ranges without re-downloading entire instructions, conserving bandwidth.
        - Media transcoding statuses originate from Supabase Functions after processing.
          They write statuses back to `MediaAsset` rows and send `company:{company_id}:media_processing` events.
          Clients waiting in `apps/prepchef` or `apps/admin-crm` update UI progress bars accordingly without reuploading.
        - Checklist undo toasts rely on the Notification & Undo Service orchestrating TTL-limited instructions.
          When TTL expires, the service pushes `undo_expired` to Realtime so every device removes the button simultaneously.
          This prevents inconsistent states across staff sidebars.
        - Staff-specific filters propagate via `/api/tasks?assigned_to=me`.
          React Query caches keyed by filter strings, and Supabase realtime events include `target_user_ids` arrays so the client knows which caches to invalidate.
        - Observability pings integrate with `/api/health/realtime` called by Vercel cron.
          The route verifies subscription counts via Supabase Admin APIs and pushes `company:{company_id}:alerts` if budgets exceed thresholds.
          Behavior architects rely on the same channel to degrade features in flight.
        - Full-screen kiosk monitors rely on passive loops, yet they still send `/api/presence` heartbeats.
          Managers watch presence boards built from those heartbeats, allowing them to redeploy tablets when offline durations exceed thresholds.
        - Staff schedules and shift changes propagate to tasks via asynchronous linking.
          When `StaffSchedule` rows update, Supabase emits `company:{company_id}:schedules`.
          `apps/prepchef` listens and reruns local assignment heuristics to highlight recommended claims for on-shift staff.
    *   **Key Interaction Flow (Sequence Diagram):**
        *   **Description:** The diagram traces a staff member loading the PrepChef dashboard, subscribing to realtime data, claiming a task, referencing a recipe, approving a heuristic combination initiated by the Task Aggregation Engine, and optionally undoing the completion while kiosk and manager surfaces stay synchronized.
        *   **Diagram (PlantUML):**
            ~~~plantuml
            @startuml
            actor StaffUser as Staff
            participant "apps/prepchef" as PrepChefApp
            participant "libs/shared/tasks" as SharedTasksLib
            participant "Next.js API Routes" as NextApi
            participant "libs/supabase" as SupabaseLib
            participant "supabase/sql" as SupabaseSQL
            participant "Task Aggregation Engine" as Aggregator
            participant "Supabase Realtime Channels" as Realtime
            participant "Notification & Undo Service" as UndoService
            participant "Media Processing Pipeline" as MediaPipeline
            participant "Supabase Storage" as Storage
            participant "apps/display" as DisplayApp
            participant "apps/admin-crm" as AdminCRM
            participant "apps/caterking" as CaterkingApp
            ' Scenario: kitchen staff obtains real-time task guidance while managers oversee flows and heuristics propose combinations.

            group Initial Dashboard Sync
            ' Staff loads PrepChef and fetches aggregated tasks plus recipes before subscribing to realtime.
            Staff -> PrepChefApp : Launch dashboard\nselect multi-event filter
            PrepChefApp -> SharedTasksLib : initialize useTaskDashboardHooks(company_id, filters)
            SharedTasksLib -> NextApi : GET /api/tasks?status=available&include=recipe
            NextApi -> SupabaseLib : build authenticated task query context
            SupabaseLib -> SupabaseSQL : select tasks scoped by company_id\nproject base fields + recipe refs
            SupabaseSQL --> SupabaseLib : task rows + counts + recipe ids
            SupabaseLib --> NextApi : typed DTO array + pagination meta
            NextApi --> SharedTasksLib : stream JSON chunk (summary counts)
            SharedTasksLib --> PrepChefApp : hydrate React Query cache + filter metadata
            note right of PrepChefApp : Server components show counts while client side attaches event filters
            PrepChefApp -> Realtime : SUBSCRIBE company:{company_id}:tasks
            Realtime --> PrepChefApp : ACK subscription + last_seen_event_id pointer
            PrepChefApp -> SharedTasksLib : register realtime handlers for tasks/events/presence
            end

            ' Presence heartbeat ensures Ops knows device health.
            loop Periodic Presence Sync
            PrepChefApp -> NextApi : POST /api/presence { device_id, focus_view, timestamp }
            NextApi -> SupabaseLib : upsert presence heartbeat
            SupabaseLib -> SupabaseSQL : update presence table + expiry_at
            SupabaseSQL --> SupabaseLib : success ack
            SupabaseLib --> NextApi : { status:"healthy", undo_banner:false }
            NextApi --> PrepChefApp : deliver presence status + TTL suggestions
            end

            ' Streaming the realtime feed into caches.
            loop Streaming Task Deltas
            Realtime -> PrepChefApp : task_changed { task_id, status, assigned_user_id, version }
            PrepChefApp -> SharedTasksLib : reconcileTaskFromRealtime(event)
            SharedTasksLib -> PrepChefApp : patch cache + emit toast directive if viewer involved
            Realtime -> DisplayApp : aggregated_task_delta used for wall board counters
            DisplayApp -> DisplayApp : update columns + highlight urgent tiles
            Realtime -> AdminCRM : push status change for oversight board
            AdminCRM -> AdminCRM : mutate Kanban card state without re-fetch
            Realtime -> CaterkingApp : deliver compact payload for lightweight ops board
            CaterkingApp -> CaterkingApp : update list + maintain offline indicator
            end

            ' Ops-level fetch for managers occurs in parallel.
            group Manager Oversight Loop
            AdminCRM -> NextApi : GET /api/events?include=task_counts
            NextApi -> SupabaseLib : fetch aggregated statuses per event
            SupabaseLib -> SupabaseSQL : query summary view + RBAC filters
            SupabaseSQL --> SupabaseLib : dataset + server timestamps
            SupabaseLib --> NextApi : typed JSON + telemetry_id
            NextApi --> AdminCRM : deliver dataset for board
            note over AdminCRM : Drag-and-drop board anchors staff assignments + heuristics prompts
            AdminCRM -> NextApi : POST /api/tasks/bulk-assign { assignments[] }
            NextApi -> SupabaseLib : call transactional RPC for assignments
            SupabaseLib -> SupabaseSQL : update each row + log audit_per_task
            SupabaseSQL --> SupabaseLib : success with per-row timestamps
            SupabaseLib -> Realtime : broadcast assignments_on_board event
            Realtime -> PrepChefApp : update cards to show manager-specified assignees
            Realtime -> DisplayApp : refresh scoreboard with new owner initials
            end

            ' Apps/caterking fetch cycle for smaller ops.
            group Lightweight Ops Monitoring
            CaterkingApp -> NextApi : GET /api/tasks?view=compact&limit=40
            NextApi -> SupabaseLib : build limited projection query
            SupabaseLib -> SupabaseSQL : select minimal fields
            SupabaseSQL --> SupabaseLib : dataset for quick glances
            SupabaseLib --> NextApi : respond with JSON + last_modified_at
            NextApi --> CaterkingApp : send payload + realtime channel hints
            CaterkingApp -> Realtime : SUBSCRIBE company:{company_id}:tasks.watchlist
            Realtime -> CaterkingApp : push minimal events referencing same DTO schema_version
            end

            ' Staff claims a task; success and conflict branches shown.
            group Task Claim Flow
            Staff -> PrepChefApp : Tap "CLAIM" on Combined Onion Prep row
            PrepChefApp -> SharedTasksLib : prepareClaimMutation(task_id, actor_id, idempotency_key)
            SharedTasksLib -> NextApi : POST /api/tasks/:id/claim { actor_id, idempotency_key }
            NextApi -> SupabaseLib : invoke claim_task RPC
            SupabaseLib -> SupabaseSQL : call claim_task(task_id, actor_id, idempotency_key)
            alt Claim Succeeds
            SupabaseSQL --> SupabaseLib : status=claimed, assigned_user_id=actor_id, undo_token token123
            SupabaseLib -> UndoService : enqueue undo token + ttl=5m
            note over UndoService : Service tracks TTL + emits expiration events
            SupabaseLib --> NextApi : normalized task DTO + audit_reference_id A123
            NextApi --> SharedTasksLib : 200 + payload + audit id + toast directives
            SharedTasksLib --> PrepChefApp : convert button to "WORKING" + show avatar chip
            SupabaseSQL -> Realtime : broadcast task_claimed event containing server timestamp
            Realtime -> PrepChefApp : deliver event to other staff tablets
            Realtime -> DisplayApp : update claimed counts + highlight actor initials
            Realtime -> AdminCRM : inform manager board of new owner
            else Claim Conflict
            SupabaseSQL --> SupabaseLib : error code conflict_claim with winner user_id
            SupabaseLib --> NextApi : propagate conflict response
            NextApi --> SharedTasksLib : 409 + winning actor_id
            SharedTasksLib --> PrepChefApp : revert optimistic update + show "Already claimed" toast
            end
            end
            ' Staff views recipe details to confirm method compliance.
            group Recipe Drawer Reference
            Staff -> PrepChefApp : Expand task row > "View Recipe"
            PrepChefApp -> SharedTasksLib : fetchRecipeWithMedia(recipe_id, version=current)
            SharedTasksLib -> NextApi : GET /api/recipes/:id?version=current
            NextApi -> SupabaseLib : query recipe row + storage metadata
            SupabaseLib -> SupabaseSQL : select recipe, steps, media_urls, allergen flags
            SupabaseSQL --> SupabaseLib : recipe json + version_id 7
            SupabaseLib --> NextApi : stream chunk #1 (metadata & hero image refs)
            NextApi --> SharedTasksLib : deliver chunk #1
            SharedTasksLib --> PrepChefApp : render drawer skeleton with hero + summary stats
            NextApi --> SharedTasksLib : stream chunk #2 (steps, media_data_url_list)
            SharedTasksLib --> PrepChefApp : hydrate instructions + show video controls
            note over PrepChefApp : Drawer stays pinned; user never leaves the list
            SharedTasksLib -> Realtime : SUBSCRIBE company:{company_id}:recipes
            Realtime -> PrepChefApp : push version_update when owner edits recipe
            PrepChefApp -> Staff : prompt to refresh recipe if version mismatch detected
            end

            ' Task completion path including undo token refresh.
            group Task Completion Flow
            Staff -> PrepChefApp : Tap "DONE" after finishing prep
            PrepChefApp -> SharedTasksLib : prepareCompleteMutation(task_id, yield_data)
            SharedTasksLib -> NextApi : POST /api/tasks/:id/complete { actor_id, portion_output }
            NextApi -> SupabaseLib : call complete_task RPC
            SupabaseLib -> SupabaseSQL : finalize status + update combined group progress
            SupabaseSQL --> SupabaseLib : success + undo_token token456 + normalized instructions
            SupabaseLib -> UndoService : refresh undo token timeline
            SupabaseLib --> NextApi : final DTO + undo deadline
            NextApi --> SharedTasksLib : return success + toast_info
            SharedTasksLib --> PrepChefApp : update card to green and show undo toast
            Realtime -> DisplayApp : highlight completed count + update top urgent list
            Realtime -> AdminCRM : show completion on manager board timeline
            end

            ' Aggregator proposes combination and manager approves.
            group Task Aggregation Suggestion Loop
            Aggregator -> SupabaseSQL : scan tasks by normalized ingredient/unit
            SupabaseSQL --> Aggregator : candidate pairs/triples with heuristics metadata
            Aggregator -> SupabaseSQL : insert suggestion rows + heuristics_diff payloads
            Aggregator -> Realtime : emit suggestion_ready event { suggestion_id, task_ids }
            Realtime -> AdminCRM : notify manager of x4 onion chop suggestion
            AdminCRM -> AdminCRM : surface inline suggestion card referencing heuristics_strength
            AdminCRM -> NextApi : POST /api/tasks/combine { task_ids[], approved_by }
            NextApi -> SupabaseLib : call combine_tasks RPC
            SupabaseLib -> SupabaseSQL : update tasks, create combined group, log audit_diff
            SupabaseSQL --> SupabaseLib : combined group summary + new group_id G44
            SupabaseLib -> Realtime : broadcast combined_task_created {group_id, aggregated_quantity}
            Realtime -> PrepChefApp : show stacked-card icon + opt-in button on row
            Realtime -> DisplayApp : update counters for combined_load
            Realtime -> UndoService : record decomposition path for rollback
            note over PrepChefApp : Staff sees call-to-action to accept combined instructions
            end

            ' Admin dissolves group if needed; ensures apps update.
            group Combined Group Rollback
            AdminCRM -> NextApi : POST /api/tasks/combine/rollback { group_id: G44 }
            NextApi -> SupabaseLib : call rollback RPC
            SupabaseLib -> SupabaseSQL : decompose combined tasks + restore prior statuses
            SupabaseSQL --> SupabaseLib : send original task payloads
            SupabaseLib -> Realtime : broadcast group_rolled_back event
            Realtime -> PrepChefApp : reinsert tasks + remove stacked icon
            Realtime -> DisplayApp : recalc counters for undone combination
            end

            ' Display summary fetch loop ensures kiosks stay up to date.
            group Display Refresh Cycle
            DisplayApp -> NextApi : GET /api/display/summary?since=timestamp
            NextApi -> SupabaseLib : read materialized view snapshot
            SupabaseLib -> SupabaseSQL : select aggregated_data + captured_at
            SupabaseSQL --> SupabaseLib : payload + captured_at meta
            SupabaseLib --> NextApi : JSON summary + handshake_id
            NextApi --> DisplayApp : respond + handshake_id for telemetry
            DisplayApp -> Realtime : SUBSCRIBE company:{company_id}:display_snapshots
            Realtime -> DisplayApp : push differential counters between polls
            note over DisplayApp : Polling fallback engages if realtime disconnects or kiosk offline
            end

            ' Undo path demonstrates Notification & Undo Service orchestration.
            group Undo Flow
            Staff -> PrepChefApp : Tap "Undo completion" within toast
            PrepChefApp -> SharedTasksLib : triggerUndo(task_id, undo_token token456)
            SharedTasksLib -> NextApi : POST /api/tasks/:id/undo { undo_token }
            NextApi -> UndoService : validate token state + actor_id
            UndoService -> SupabaseLib : call undo RPC to revert status
            SupabaseLib -> SupabaseSQL : restore previous status + assigned_user_id, log audit
            SupabaseSQL --> SupabaseLib : reverted task payload
            SupabaseLib --> UndoService : ack + mark token consumed
            UndoService --> NextApi : respond success + undone_state
            NextApi --> SharedTasksLib : send reverted DTO + undo_available_until=null
            SharedTasksLib --> PrepChefApp : update card visuals to show undone state
            Realtime -> PrepChefApp : send undo_broadcast to other devices
            Realtime -> DisplayApp : revert counters to reflect undone completion
            note over UndoService : TTL countdown continues for other pending undo tokens
            end

            ' Observability ensures audit correlation.
            group Telemetry and Audit Emission
            NextApi -> SupabaseLib : request audit_reference_id for action_type
            SupabaseLib -> SupabaseSQL : insert audit log row with diff jsonb + actor_id
            SupabaseSQL --> SupabaseLib : ack with audit_id A123
            SupabaseLib --> NextApi : return audit_id + trace_id
            NextApi -> Realtime : emit audit_summary_event for Ops watchers
            Realtime -> AdminCRM : update audit timeline widget to show new entry
            Realtime -> CaterkingApp : optionally show alert when anomalies occur
            end

            ' Realtime dropout fallback ensures deterministic state.
            alt Realtime channel dropout detected
            Realtime -> PrepChefApp : disconnect notice
            PrepChefApp -> SharedTasksLib : start polling scheduler with delta queries
            SharedTasksLib -> NextApi : GET /api/tasks?since=last_event&limit=100
            NextApi -> SupabaseLib : fetch incremental rows using server timestamps
            SupabaseLib -> SupabaseSQL : query tasks updated after last_event
            SupabaseSQL --> SupabaseLib : incremental dataset
            SupabaseLib --> NextApi : payload referencing same schema_version
            NextApi --> SharedTasksLib : deliver delta set
            SharedTasksLib --> PrepChefApp : merge incremental updates while showing offline banner
            else Realtime stable
            Realtime -> PrepChefApp : keep sending task_changed events
            end

            ' Media processing acknowledges watchers awaiting recipe videos.
            group Media Processing Update
            AdminCRM -> NextApi : POST /api/media/sign { file_name, mime_type }
            NextApi -> SupabaseLib : register pending media asset entry
            SupabaseLib -> SupabaseSQL : insert MediaAsset row + status=pending
            SupabaseSQL --> SupabaseLib : ack
            SupabaseLib --> NextApi : return signed URL + asset_id
            NextApi --> AdminCRM : deliver signed URL + policy_token
            AdminCRM -> Storage : Upload bytes to signed URL
            Storage -> MediaPipeline : emit file_uploaded event referencing asset_id
            MediaPipeline -> SupabaseSQL : update MediaAsset status=processing + checksum
            SupabaseSQL --> MediaPipeline : ack
            MediaPipeline -> Realtime : emit media_processing_update { asset_id, status:processing }
            Realtime -> PrepChefApp : update recipe drawer to show transcoding indicator
            MediaPipeline -> SupabaseSQL : finalize status ready + thumbnail_url
            SupabaseSQL --> MediaPipeline : ack
            MediaPipeline -> Realtime : emit media_processing_update { asset_id, status:ready, media_urls }
            Realtime -> PrepChefApp : refresh drawer and enable playback button
            Realtime -> AdminCRM : show "Upload ready" indicator on CMS list
            end
            ' Staff schedules influence recommended claims.
            group Schedule Driven Recommendations
            AdminCRM -> NextApi : POST /api/schedules { user_id, event_id, shift_start, shift_end }
            NextApi -> SupabaseLib : insert StaffSchedule row
            SupabaseLib -> SupabaseSQL : write schedule + apply RLS guard
            SupabaseSQL --> SupabaseLib : ack with schedule_id
            SupabaseLib -> Realtime : emit schedules_updated event
            Realtime -> PrepChefApp : feed event into SharedTasksLib heuristics
            SharedTasksLib -> PrepChefApp : highlight "Recommended" badges for on-shift staff
            Realtime -> DisplayApp : adjust staffing heatmap cards
            end

            ' Observability cron ensures realtime budgets maintained.
            group Observability Ping Cycle
            note over NextApi : Vercel cron hits /api/health/realtime for tenant budgets
            NextApi -> SupabaseLib : query realtime subscription counts per company
            SupabaseLib -> SupabaseSQL : read admin metrics view
            SupabaseSQL --> SupabaseLib : metrics dataset
            SupabaseLib --> NextApi : structure metrics + threshold comparisons
            NextApi -> Realtime : emit alerts when thresholds breached
            Realtime -> AdminCRM : show alert banner "Realtime saturation; degrade features"
            Realtime -> PrepChefApp : instruct clients to limit optional subscriptions
            end

            ' Stats for kiosk watchers tie into presence events.
            group Kiosk Presence Monitoring
            DisplayApp -> NextApi : POST /api/presence { device_id:"display-wall-1", focus_view:"metrics" }
            NextApi -> SupabaseLib : update presence with kiosk flag
            SupabaseLib -> SupabaseSQL : store heartbeat + kiosk metadata
            SupabaseSQL --> SupabaseLib : ack
            SupabaseLib -> Realtime : emit presence_update { device_id, status }
            Realtime -> AdminCRM : update device monitoring panel
            Realtime -> PrepChefApp : optionally show kiosk offline indicator
            end

            ' End of scenario ensures watchers know final state.
            @enduml
            ~~~
    *   **Data Transfer Objects (DTOs):**
        - `POST /api/tasks/:id/claim`
          - Request JSON:
            - `taskId`: string UUID referencing `tasks.id`; provided redundantly for validation even though it appears in the path.
            - `actorId`: string UUID referencing `users.id`, enforced to belong to the same company_id.
            - `idempotencyKey`: string hashed on client (`taskId + actorId + timestamp`) to gate duplicate submissions.
            - `clientTimestamp`: ISO-8601 string used for latency telemetry but never for ordering.
          - Response JSON:
            - `data.task`: object with `id`, `company_id`, `event_id`, `name`, `status`, `assigned_user_id`, `assigned_user_display_name`, `quantity`, `unit`, `priority`, `combined_group_id`, `undo_available_until`, `station_id`, and `instructions_ref`.
            - `data.audit_reference_id`: string referencing `audit_logs.id` for downstream investigation.
            - `meta.schema_version`: integer, enabling compatibility gating across apps.
            - `meta.realtime_channel`: string `company:{company_id}:tasks` confirming which subscription will echo the mutation.
        - `POST /api/tasks/:id/complete`
          - Request JSON:
            - `taskId`: string path parameter validated against payload.
            - `actorId`: UUID representing the staff finisher.
            - `portionOutput`: object `{ quantity: number, unit: string }` allowing the server to scale aggregated tasks.
            - `notes`: optional string for per-task comments stored in `task_comments` table.
            - `idempotencyKey`: string reused across retries to avoid duplicate completions.
          - Response JSON:
            - `data.task`: includes final `status`, `completed_at`, `completed_by_user_id`, `undo_token`, `undo_available_until`, and `combined_group_progress`.
            - `data.standardized_instructions`: array summarizing any auto-generated merge notes for record keeping.
            - `meta.undo_toast`: object describing message text, TTL milliseconds, and `toast_id` consumed by Notification & Undo Service clients.
            - `meta.trace_id`: string that maps to observability spans.
        - `POST /api/tasks/combine`
          - Request JSON:
            - `taskIds`: ordered array of UUIDs referencing base tasks; validation ensures same `company_id`, `unit`, and compatible `status`.
            - `approvedBy`: UUID referencing `users.id` (manager or event lead) stored in `combined_task_groups.approved_by_user_id`.
            - `heuristicsMetadata`: object containing `similarity_score`, `normalized_ingredient`, `unit_conversion_trace`, and `feature_flag_state`.
            - `idempotencyKey`: ensures repeated approvals do not create duplicate groups.
          - Response JSON:
            - `data.combinedGroup`: object with `id`, `company_id`, `base_task_ids`, `aggregated_quantity`, `unit`, `approved_by_user_id`, `created_at`, and `heuristics_metadata`.
            - `data.primaryTask`: the surviving task DTO referencing the combined group for UI display.
            - `meta.audit_reference_id`: for compliance.
            - `meta.realtime_events`: array describing which channels (`tasks`, `display_snapshots`) will broadcast updates.
        - `GET /api/tasks`
          - Query parameters:
            - `event_id`, `station`, `status`, `assigned_to`, `combined`, `cursor`, and `limit` with defaults defined in `libs/shared/pagination`.
            - `include`: comma-separated list allowing `recipe_snippet`, `method_badges`, `staff_presence_hint`.
          - Response JSON:
            - `data`: array of task DTOs each containing nested `recipe_snippet` (name, version, hero_image_url) when requested.
            - `meta.pagination`: `{ cursor, next_cursor, prev_cursor, total_estimate }` enabling infinite scroll.
            - `meta.summary`: aggregated counts for `available`, `claimed`, `completed`, `urgent`, grouped by station.
            - `links.poll`: absolute URL to use when realtime fallback is required.
        - `GET /api/display/summary`
          - Query parameters: `since`, `event_scope`, `station_scope`, `agg=hourly|live` to tune kiosk density.
          - Response JSON:
            - `data.cards`: array of summary cards (task counts, urgent tasks, biggest tasks) referencing aggregated tables.
            - `data.assignments`: condensed list of `{ task_id, user_display_name, status }` for marquee rendering.
            - `meta.captured_at`: ISO timestamp of snapshot plus `staleness_ms` so kiosk can display degrade notices.
            - `meta.realtime_channel`: `company:{company_id}:display_snapshots` string for delta subscription.
        - `POST /api/media/sign`
          - Request JSON:
            - `fileName`: string used for display naming and storage path hashing.
            - `mimeType`: validated string to enforce allowed media types (image/*, video/*).
            - `companyId`: implicitly derived from JWT but echoed for deterministic storage prefixes.
            - `recipeId` or `methodDocumentId`: optional references linking the media to content.
          - Response JSON:
            - `data.asset`: object with `id`, `company_id`, `status`, `storage_path`, and `checksum_placeholder`.
            - `data.upload`: `{ url, headers, expiry }` describing the signed PUT request.
            - `meta.callbacks`: describes webhook topics `media_processing_update` clients should expect from realtime.
        - `GET /api/recipes/:id`
          - Query parameters: `version`, `include=ingredients|media`, `stream=true|false`.
          - Response JSON:
            - `data.recipe`: object with `id`, `company_id`, `name`, `version`, `steps` (array of JSON objects), `ingredients` (normalized list), `media_urls` (array of storage references), `allergen_flags`, and `last_reviewed_by`.
            - `data.methods`: optional array referencing complementary method documents for training overlays.
            - `meta.streaming_chunks`: describes chunk sizes so clients can manage progressive rendering.
            - `links.media`: list of signed URLs or tokens valid for playback.
        - `POST /api/tasks/:id/undo`
          - Request JSON:
            - `taskId`: string path parameter verifying target.
            - `undoToken`: string issued at claim/complete time; must match `undo_service_tokens.token`.
            - `reason`: optional enum (`mistap`, `reassign`, `other`) stored for analytics.
          - Response JSON:
            - `data.task`: reverted DTO containing `status`, `assigned_user_id`, `completed_at`, `undo_available_until=null`.
            - `data.audit_reference_id`: ensures the reversal is traceable.
            - `meta.undo_queue_state`: describes remaining undo tokens for the actor, enabling UI gating.
        - `POST /api/tasks/bulk-assign`
          - Request JSON:
            - `assignments`: array of `{ taskId, targetUserId, priorityOverride?, note? }` objects processed transactionally.
            - `reason`: string stored in audit logs (e.g., `shift-handoff`).
            - `idempotencyKey`: ensures repeated drag/drop events do not double mutate tasks.
          - Response JSON:
            - `data.assignments`: list of assignments actually applied with server timestamps.
            - `meta.failed`: array of `{ taskId, failureCode, blockingUser }` for tasks that could not be assigned.
            - `meta.realtime_channel`: channel names that will broadcast deltas so UI caches can skip manual refresh.
        - `POST /api/presence`
          - Request JSON:
            - `deviceId`: string describing the tablet or kiosk.
            - `focusView`: enum (`tasks`, `my`, `filters`, `display`) allowing Ops to know which surface is active.
            - `clientVersion`: semantic version string to help identify outdated builds.
            - `heartbeatAt`: ISO timestamp; server validates drift.
          - Response JSON:
            - `data.presence`: object with `device_id`, `last_seen_at`, `status`, and `ttl_seconds`.
            - `meta.alert`: optional message instructing the device to refresh or limit subscriptions.
        - `GET /api/methods/:id`
          - Query parameters: `include=video|steps|notes`, `version`, `task_context` for contextual recommendations.
          - Response JSON:
            - `data.method`: `{ id, company_id, title, steps (array with `order`, `instruction`, `media_ref`), skill_level, last_reviewed_by }`.
            - `data.training`: optional object describing recommended tasks and `completion_badge` states.
            - `meta.cache`: indicates TTL for caching plus `requires_online=true` flag because offline mode is unsupported.
            - `links.media`: signed URLs or playback tokens referencing Supabase Storage objects.
                -   ` G E T   / a p i / e v e n t s ` 
                     -   Q u e r y   p a r a m e t e r s :   ` d a t e _ s t a r t ` ,   ` d a t e _ e n d ` ,   ` s t a t u s ` ,   ` i n c l u d e = t a s k s | s t a f f `   e n a b l i n g   m a n a g e r s   t o   s c o p e   d a s h b o a r d s   p e r   s e r v i c e   w i n d o w . 
                     -   R e s p o n s e   J S O N : 
                         -   ` d a t a . e v e n t s ` :   a r r a y   o f   ` {   i d ,   c o m p a n y _ i d ,   n a m e ,   s c h e d u l e d _ a t ,   s t a t u s ,   l o c a t i o n ,   n o t e s ,   t a s k _ c o u n t s   } `   o b j e c t s   u s e d   b y   ` a p p s / a d m i n - c r m `   a n d   ` a p p s / c a t e r k i n g ` . 
                         -   ` m e t a . s u m m a r y ` :   a g g r e g a t e d   t o t a l s   ( ` e v e n t s _ a c t i v e ` ,   ` t a s k s _ t o t a l ` ,   ` t a s k s _ c l a i m e d ` )   p o w e r i n g   h e a d e r   c o u n t e r s   o n   e v e r y   c l i e n t . 
                         -   ` l i n k s . c r e a t e ` :   t e m p l a t e d   U R L   f o r   ` / a p i / e v e n t s `   s o   w a l l   d i s p l a y s   c a n   s u r f a c e   q u i c k   a c t i o n s   w h e n   m a n a g e r s   a u t h e n t i c a t e . 
                 -   ` P O S T   / a p i / d i s p l a y / s n a p s h o t ` 
                     -   R e q u e s t   J S O N : 
                         -   ` c a p t u r e d B y ` :   U U I D   r e f e r e n c i n g   t h e   a u t o m a t i o n   a c t o r   o r   m a n a g e r   r e q u e s t i n g   t h e   s n a p s h o t . 
                         -   ` f i l t e r s ` :   o b j e c t   d e s c r i b i n g   ` e v e n t _ s c o p e ` ,   ` s t a t i o n _ s c o p e ` ,   a n d   ` p r i o r i t y _ t h r e s h o l d `   s o   s n a p s h o t s   a r e   c o m p a r a b l e . 
                     -   R e s p o n s e   J S O N : 
                         -   ` d a t a . s n a p s h o t ` :   ` {   i d ,   c o m p a n y _ i d ,   p a y l o a d   ( j s o n b ) ,   c a p t u r e d _ a t   } ` ,   m i r r o r i n g   t h e   ` D i s p l a y S n a p s h o t `   e n t i t y   f o r   o f f l i n e   a u d i t s . 
                         -   ` m e t a . p o l l _ i n t e r v a l ` :   n u m e r i c   m i l l i s e c o n d s   i n s t r u c t i n g   k i o s k   l o o p s   w h e n   t o   r e q u e s t   t h e   n e x t   s n a p s h o t   i f   r e a l t i m e   i s   t h r o t t l e d . 
                         -   ` m e t a . r e a l t i m e _ c h a n n e l ` :   e n s u r e s   k i o s k   w a t c h e r s   k n o w   t o   s u b s c r i b e   t o   ` c o m p a n y : { c o m p a n y _ i d } : d i s p l a y _ s n a p s h o t s `   f o r   d e l t a s . 
                 -   ` P O S T   / a p i / t a s k s / s u g g e s t i o n s ` 
                     -   R e q u e s t   J S O N : 
                         -   ` f i l t e r s ` :   o b j e c t   d e s c r i b i n g   ` e v e n t _ i d ` ,   ` s t a t i o n ` ,   ` i n g r e d i e n t ` ,   l e t t i n g   m a n a g e r s   r e q u e s t   t a r g e t e d   h e u r i s t i c   r u n s . 
                         -   ` l i m i t ` :   i n t e g e r   c o n t r o l l i n g   t h e   n u m b e r   o f   s u g g e s t i o n s   g e n e r a t e d   p e r   c a l l   t o   a v o i d   U I   o v e r w h e l m . 
                         -   ` f e a t u r e F l a g C o n t e x t ` :   m a p   o f   f l a g   k e y s   t o   v a l u e s   s o   S u p a b a s e   f u n c t i o n s   r e c o r d   w h i c h   h e u r i s t i c s   w e r e   e n a b l e d   d u r i n g   e v a l u a t i o n . 
                     -   R e s p o n s e   J S O N : 
                         -   ` d a t a . s u g g e s t i o n s ` :   a r r a y   o f   ` {   s u g g e s t i o n _ i d ,   t a s k _ i d s [ ] ,   s i m i l a r i t y _ s c o r e ,   n o r m a l i z e d _ i n g r e d i e n t ,   r e c o m m e n d e d _ u n i t ,   r a t i o n a l e   } `   p a i r s   p i p e d   d i r e c t l y   i n t o   U I   s u g g e s t i o n   d r a w e r s . 
                         -   ` m e t a . h e u r i s t i c _ v e r s i o n ` :   s t r i n g   r e f e r e n c i n g   t h e   h e u r i s t i c s   r e l e a s e   ( e . g . ,   ` c o m b i n e . v 3 ` )   f o r   t e l e m e t r y   c o r r e l a t i o n . 
                         -   ` m e t a . s l a ` :   m i l l i s e c o n d s   d e s c r i b i n g   h o w   l o n g   t h e   a s y n c h r o n o u s   S u p a b a s e   f u n c t i o n   t o o k ,   h e l p i n g   a r c h i t e c t s   t u n e   b a t c h i n g   s t r a t e g i e s . 
 
 