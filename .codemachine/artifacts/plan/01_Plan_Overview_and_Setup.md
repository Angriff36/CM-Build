<!-- anchor: project-plan-header -->
# Project Plan: CaterKing Kitchen Management Platform

**Version:** 1.0
**Date:** 2025-05-09
**Generated By:** Codex (GPT-5)

<!-- anchor: project-overview -->
## 1. Project Overview

*   **Goal:** Deliver a multi-tenant, real-time kitchen management suite that unifies staff task execution, managerial oversight, and recipe knowledge into a Turbo-powered Next.js + Supabase platform with mobile-first UX and kiosk displays.
*   **High-Level Requirements Summary:**
    - Real-time task board supporting claim/complete/undo, manual assignment, and rich filtering across simultaneous events.
    - Task consolidation engine suggesting normalized combinations with unit conversions and human approval, plus undo/audit trails.
    - Recipes, methods, and media knowledge base with versioning, media upload pipeline, and drawer-style viewers on every surface.
    - Multi-tenant Supabase Postgres schema enforcing RLS, Doppler-managed secrets, strict role hierarchy (staff/manager/event lead/owner).
    - Apps for PrepChef PWA, CaterKing Lite, Admin CRM, and passive wall displays, all sharing design tokens and Supabase realtime feeds.
    - Supabase-powered storage, media processing, and presence tracking with telemetry, feature flags, and deployment governance.
*   **Key Assumptions:**
    - Phase 1 ships as online-only PWAs; React Native shells remain future work but inform shared hooks and tokens.
    - Supabase (Postgres/Auth/Storage/Realtime/Functions) plus Vercel Edge hosting cover all backend needs; no additional infra.
    - Feature flags via Flagsmith and secrets via Doppler are available from day one; no ad-hoc env overrides.
    - Media uploads capped at 500MB per asset with Supabase Functions handling transcoding and thumbnails asynchronously.
    - Undo scope limited to task claim/complete; other entities rely on audit-driven manual corrections in MVP.

<!-- anchor: core-architecture -->
## 2. Core Architecture

*   **Architectural Style:** Modular monolithic Turbo repo with Next.js App Router surfaces backed by Supabase-managed persistence, realtime, and storage; server actions stay thin while business logic lives in shared libraries and Supabase RPCs.
*   **Technology Stack:**
    *   Frontend: Next.js 15 (App Router, React Server Components), React 18, Tailwind CSS + ShadCN via `@caterkingapp/ui`, React Query, Framer Motion (opt-in), Storybook.
    *   Backend: Next.js API routes/server actions (Edge + Node runtimes) orchestrating Supabase RPCs/functions; Supabase Functions for heuristics/media.
    *   Database: Supabase Postgres with JSONB-heavy schema, pgTAP tests, PITR enabled, libs/supabase generated types.
    *   Messaging/Queues: Supabase Realtime channels (`company:{company_id}:{entity}`) and optional Postgres LISTEN/NOTIFY triggers.
    *   Deployment: Vercel for apps/APIs, Supabase cloud for DB/Auth/Storage/Realtime/Functions, Doppler for secrets, Flagsmith for feature flags.
    *   Other Key Libraries/Tools: pnpm 8+, Turbo 2+, Vitest, Playwright, OpenTelemetry, Changesets, Supabase CLI, Doppler CLI, Flagsmith SDK, Logflare/Datadog exporters.
*   **Key Components/Services:** PrepChef PWA, CaterKing Lite, Admin CRM, Display app, libs/ui (tokens + components), libs/shared (domain models, access control, heuristics), libs/supabase (clients + RPC wrappers), libs/rag (future ingestion), Supabase schema + functions, Media pipeline, Notification/Undo service, Feature flag gateway, Observability stack. (Component Diagram planned in PlantUML – see Section 2.1 / Iteration I1.T3.)
*   **Data Model Overview:** Multi-tenant schema with Companies ? Users (roles via RoleAssignment + Supabase Auth), Events ? Tasks (status, quantity, station, undo_token, combined_group_id), CombinedTaskGroup (heuristic metadata), Recipes/MethodDocuments (JSONB steps/media), MediaAssets (upload pipeline), NotificationPreferences, Presence/RealtimeSubscription tables, AuditLogs. (ERD planned in Mermaid – see Section 2.1 / Iteration I1.T4.)
*   **API Contract Style:** RESTful JSON over Next.js route handlers + server actions, documented via OpenAPI v3 YAML; Supabase RPCs (`claim_task`, `complete_task`, `combine_tasks`, etc.) serve as authoritative mutation layer. (Initial OpenAPI spec planned – see Section 2.1 / Iteration I2.T1.)
*   **Communication Patterns:** React Server Components hydrate lists via shared fetchers, React Query manages optimistic cache + Supabase realtime invalidations, Presence + Display rely on summary endpoints/materialized views, feature flags evaluated server-side and injected via middleware, Observability spans track API?RPC?Realtime flows. (Sequence diagram planned – see Section 2.1 / Iteration I2.T2.)

<!-- anchor: key-artifacts -->
## 2.1. Key Architectural Artifacts Planned

*   Component Diagram (PlantUML) – Visualize apps, shared libs, Supabase services, and observability stack touchpoints. Created/maintained in `docs/diagrams/component_overview.puml` during I1.T3; reused for onboarding and dependency audits.
*   Database ERD (Mermaid) – Capture tenant-scoped schema, primary relationships, undo/combined group mapping. Authored in `docs/diagrams/data_model.mmd` during I1.T4 and updated when migrations land.
*   Deployment Diagram (PlantUML) – Show GitHub Actions, Vercel, Supabase, Doppler, Flagsmith interactions. Produced in `docs/diagrams/deployment_view.puml` during I1.T5.
*   API Reference (OpenAPI v3 YAML) – Define REST routes + schemas for tasks, events, recipes, media, notifications. Created in `api/openapi/caterking.yaml` during I2.T1 with lint automation.
*   Task Lifecycle Sequence Diagram (Mermaid) – Document claim?complete?undo flow plus realtime broadcasts. Authored in `docs/diagrams/task_sequence.mmd` during I2.T2.
*   Feature Flag Register (Markdown) – Track flag purpose, rollout, telemetry references. Stored in `docs/adr/feature_flags.md`, initiated during I2.T3.
*   Supabase Migration Playbook (Markdown) – Step-by-step process for applying/reverting migrations + RLS tests. Added under `docs/ops/supabase_migration_playbook.md` during I1.T6.
*   Media Pipeline Flowchart (Mermaid) – Depict signed uploads, functions, notifications. Authored in `docs/diagrams/media_pipeline.mmd` during I3.T3.
*   Testing Matrix (Markdown) – Map Vitest, Playwright, Storybook coverage to features. Stored in `docs/quality/testing_matrix.md` by I3.T5 and iterated in later sprints.
*   Display Snapshot Contract (JSON Schema) – Validate kiosk payloads. Stored in `docs/contracts/display_snapshot.schema.json`, drafted in I4.T2.
*   Notification/Undo Spec (Markdown) – Document TTL, payload, telemetry. Maintained in `docs/specs/undo_notification.md` starting I2.T5.
*   Access Control Matrix (Markdown table) – Map roles vs actions vs RLS policies. Authored in `docs/specs/access_matrix.md` during I1.T2 and refined later.

<!-- anchor: directory-structure -->
## 3. Directory Structure

Root Directory: `caterking-platform/`

```
caterking-platform/
+-- apps/
¦   +-- prepchef/                # Staff mobile PWA (Next.js App Router)
¦   +-- caterking/               # Lightweight ops app for small teams
¦   +-- admin-crm/               # Manager/owner dashboard + CMS
¦   +-- display/                 # Passive wall display client
+-- libs/
¦   +-- ui/                      # ShadCN/Tailwind design system, tokens, Storybook stories
¦   +-- shared/                  # Domain models, Zod schemas, feature flag helpers, RBAC logic
¦   +-- supabase/                # Typed client factories, RPC wrappers, realtime adapters
¦   +-- rag/                     # Future doc ingestion + embeddings (Python tooling)
¦   +-- mcp/                     # MCP automation/integration helpers
+-- supabase/
¦   +-- migrations/              # Timestamped SQL migrations + RLS policies
¦   +-- seeds/                   # Tenant fixture data for local/staging
¦   +-- functions/               # Supabase Edge Functions (heuristics, media, cron)
+-- api/
¦   +-- openapi/                 # OpenAPI specs, JSON Schemas, lint configs
+-- docs/
¦   +-- diagrams/                # PlantUML/Mermaid sources for components, ERD, flows
¦   +-- specs/                   # Feature specs (undo, access matrix, media)
¦   +-- adr/                     # Architecture Decision Records + flag register
¦   +-- ops/                     # Runbooks, migration playbooks, incident templates
+-- tests/
¦   +-- e2e/                     # Playwright suites per app
¦   +-- smoke/                   # Targeted critical-path scripts
¦   +-- fixtures/                # Shared scenario data + mock payloads
+-- tooling/
¦   +-- scripts/                 # CLI helpers (lint hooks, telemetry checks)
¦   +-- github/                  # Workflow templates, action configs
+-- .changeset/                  # Changesets for versioned packages
+-- turbo.json                   # Turbo pipeline definitions
+-- package.json / pnpm-workspace.yaml
+-- README.md                    # Project overview + setup instructions
+-- CONTRIBUTING.md              # Dev workflow + runbooks references
+-- vercel.json                  # Vercel headers, rewrites, edge middleware
+-- doppler-template.yaml        # Secrets manifest (no actual secrets)
```

<!-- anchor: directives-process -->
## 4. Directives & Strict Process

1. Honor user-imposed command constraints (e.g., avoid unnecessary listings) unless debugging a critical failure; automation tasks must script specific targets instead of ad-hoc exploration.
2. All Supabase schema edits follow the migration playbook: update SQL under `supabase/migrations`, regenerate types, run pgTAP tests, document changes in ADR + release notes before merge.
3. Shared libraries are the single source of truth; apps may only import via `@caterkingapp/*` aliases, and new utilities must include Vitest coverage plus Storybook docs where UI-related.
4. Feature delivery requires dual sign-off: architectural artifact updated (diagram/spec), implementation complete with tests, telemetry in place, and flag rollout documented in `feature_flags.md`.
5. Every iteration must maintain testable increments; tasks include acceptance criteria referencing artifacts or files to keep autonomous agents aligned and parallelizable where dependencies allow.
